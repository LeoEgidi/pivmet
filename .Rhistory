rel <- array(0, dim =c(3, dim(rel_est$rel_mean)[1],
dim(rel_est$rel_mean)[3]))
raw <- array(0, dim =c(3, dim(mcmc$mcmc_mean_raw)[1],
dim(mcmc$mcmc_mean_raw)[3]))
rel[1,,] <-  rel_est$rel_mean[,1,]
rel[2,,] <-  rel_est$rel_mean[,2,]
rel[3,,] <-  rel_est$rel_weight
raw[1,,] <-  mcmc$mcmc_mean_raw[,1,]
raw[2,,] <-  mcmc$mcmc_mean_raw[,2,]
raw[3,,] <-  mcmc$mcmc_weight_raw
}
}
n.iter <- rel_est$final_it
true.means <- mcmc$Mu
if (type=="chains" ){
mains <- c("mean", "sd", "weight")
ylabs <- c(expression(mu), expression(tau), expression(pi))
if (is.vector(y)){
if (par=="all"){
par(mfrow=c(2,3), oma=c(0,0,0,0), mar =c(5,3,2,1))
k <- dim(raw)[3]
for (j in 1:3){
#plot
matplot(raw[j,,], type="l", xlab="",
ylab=ylabs[j], main= paste("Raw ", mains[j],"s", sep=""), cex.lab =1.8,
cex.main=1.8)
}
for (j in 1:3){
#plot the relabeled
matplot(rel[j,,], type="l", xlab="Iterations",
ylab=ylabs[j], main= paste("Rel ", mains[j],"s", sep=""),
cex.main=1.8, cex.lab =1.8)
}
cat("Description: traceplots of the raw MCMC chains and the relabelled chains for all the model parameters: means, sds and weights. Each colored chain corresponds to one of the k distinct parameters of the mixture model. Overlapping chains may reveal that the MCMC sampler is not able to distinguish between the components.")
}else{
k <- dim(raw)[2]
par(mfrow=c(1,2), oma=c(0,0,0,0), mar =c(5,3,3,1))
#plot
matplot(raw, type="l", xlab="Iterations",
ylab="", main= paste("Raw ", par,"s", sep=""),
cex.main=1.8,cex.lab =1.8)
#plot the relabeled
matplot(rel, type="l",
xlab="Iterations",
ylab="",
main= paste("Rel ", par,"s", sep=""), cex.main=1.8,
cex.lab =1.8)
cat(paste("Description: traceplot of the raw MCMC chains and the relabelled chains for the "), par,"s parameters. Each colored chain corresponds to one of the k distinct parameters of the mixture model. Overlapping chains may reveal that the MCMC sample is not able to distinguish between the components.", sep="")
}
}else{
if (par=="all"){
par(mfrow=c(2,2), oma=c(0,0,0,0), mar =c(5,4.6,2,1))
k <- dim(raw)[3]
mains = c("mean 1st coord", "mean 2nd coord", "weight")
ylabs = c(expression(mu[,1]), expression(mu[,2]), expression(pi))
#
# for (j in 1:3){
#   #plot
#   matplot(raw[j,,], type="l", xlab="",
#           ylab=ylabs[j], main= paste("Raw ", mains[j], sep=""),
#           cex.main=1.8, cex.lab =1.8)
# }
# for (j in 1:3){
#   #plot the relabeled
#   matplot(rel[j,,], type="l", xlab="Iterations",
#           ylab=ylabs[j], main= paste("Rel ", mains[j], sep=""),
#           cex.lab =1.8, cex.main=1.8)
# }
h=1
plot(raw[1,,h], raw[2, ,h], col=h, pch =1, bg =h,
cex.main =1.8, main ="Raw means", cex.lab=1.8, xlab=
expression(mu[1]), ylab =expression(mu[2]),
xlim= c(min(raw[1,,]-10), max(raw[1,,])+10),
ylim= c(min(raw[2,,]-10), max(raw[2,,])+10))
for (h in 2:k){
points(raw[1,,h], raw[2, ,h], col=h, pch =1, bg=h)
}
matplot(raw[3,,], type="l",
ylab=ylabs[3], main= paste("Raw ", mains[3],"s", sep=""),
cex.main=1.8, cex.lab =1.8, xlab ="Iterations")
h=1
plot(rel[1,,h], rel[2, ,h], col=h, pch =1, bg =h,
cex.main =1.8, main ="Rel means", cex.lab=1.8, xlab=
expression(mu[1]), ylab =expression(mu[2]),
xlim= c(min(rel[1,,]-10), max(rel[1,,])+10),
ylim= c(min(rel[2,,]-10), max(rel[2,,])+10))
for (h in 2:k){
points(rel[1,,h], rel[2, ,h], col=h, pch =1, bg=h)
}
matplot(rel[3,,], type="l",
ylab=ylabs[3], main= paste("Rel ", mains[3],"s", sep=""),
cex.main=1.8, cex.lab =1.8, xlab ="Iterations")
cat("Description: traceplots of the raw MCMC chains and the relabelled chains for the model parameters means and weights. Each colored chain corresponds to one of the k distinct parameters of the mixture model. Overlapping chains may reveal that the MCMC sample is not able to distinguish between the components.")
}else{
if (par=="mean"){
k <- dim(raw)[3]
par(mfrow=c(1,2), oma=c(0,0,0,0), mar =c(5,4.6,2,1))
# matplot(raw[,1,], type="l", xlab="",
#         ylab=expression(mu[1]), main= paste("Raw ", par,"s", sep=""),
#         cex.lab =1.8, cex.main=1.8 )
# #plot the second component
# matplot(raw[,2,], type="l", xlab="",
#         ylab=expression(mu[2]), main= paste("Raw ", par,"s", sep=""),
#         cex.lab =1.8, cex.main=1.8)
#
# #plot the first relabelled component
# matplot(rel[,1,],type="l", xlab="Iterations",
#         ylab=expression(mu[1]),
#         main= paste("Rel ", par,"s", sep=""),cex.lab =1.8, cex.main=1.8)
#
# #plot the second relabelled component
# matplot(rel[,2,],type="l", xlab="Iterations",
#         ylab=expression(mu[2]),
#         main= paste("Rel ", par,"s", sep=""),cex.lab =1.8, cex.main=1.8)
h=1
plot(raw[,1,h], raw[, 2,h], col=h, pch =1, bg =h,
cex.main =1.8, main ="Raw means", cex.lab=1.8, xlab=
expression(mu[1]), ylab =expression(mu[2]),
xlim= c(min(raw[,1,]-10), max(raw[,1,])+10),
ylim= c(min(raw[,2,]-10), max(raw[,2,])+10))
for (h in 2:k){
points(raw[,1,h], raw[,2 ,h], col=h, pch =1, bg=h)
}
h=1
plot(rel[,1,h], rel[,2,h], col=h, pch =1, bg =h,
cex.main =1.8, main ="Rel means", cex.lab=1.8, xlab=
expression(mu[1]), ylab =expression(mu[2]),
xlim= c(min(rel[,1,]-10), max(rel[,1,])+10),
ylim= c(min(rel[,2,]-10), max(rel[,2,])+10))
for (h in 2:k){
points(rel[,1,h], rel[,2 ,h], col=h, pch =1, bg=h)
}
cat(paste("Description: traceplot of the raw MCMC chains and the relabelled chains for the "), par,"s parameters (coordinate 1 and 2). Each colored chain corresponds to one of the k distinct parameters of the mixture model. Overlapping chains may reveal that the MCMC sample is not able to distinguish between the components.", sep="")
}else if(par=="weight"){
par(mfrow=c(1,2), oma=c(0,0,0,0), mar =c(5,4.6,2,1))
matplot(raw, type="l", xlab="Iterations",
ylab=expression(pi), main= paste("Raw ", par,"s", sep=""),
cex.lab =1.8, cex.main=1.8)
matplot(rel,type="l", xlab="Iterations",
ylab=expression(pi),
main= paste("Rel ", par,"s", sep=""),
cex.lab =1.8, cex.main=1.8)
cat(paste("Description: traceplot of the raw MCMC chains and the relabelled chains for the "), par,"s parameters. Each colored chain corresponds to one of the k distinct parameters of the mixture model. Overlapping chains may reveal that the MCMC sample is not able to distinguish between the components.", sep="")
}else if (par=="sd"){
return(cat("No sds available in two dimensions: they are the same for each group"))
}
}
}
}else if(type=="hist"){
if (is.vector(y)){
par(mfrow=c(1,2), mar=c(5,5,4,1))
hist(y, breaks=40, prob = TRUE,
main = paste("Raw means"), cex.main =1.8,
col="navajowhite1", border="navajowhite1", cex.lab =1.8)
points(colMeans(mcmc$mcmc_mean_raw), rep(0, length(true.means)),
col="red", pch=21,  bg="red")
lines(density(y), lty=1, lwd=3, col="blue")
hist(y, breaks=40, prob = TRUE,
main= paste("Rel means"), cex.main=1.8,
col="navajowhite1", border="navajowhite1", cex.lab =1.8)
points(est, rep(0, length(true.means)),
col="red", pch=21,  bg="red")
lines(density(y), lty=1, lwd=3, col="blue")
cat("Description: histograms of the data along with the estimated posterior means (red points) from raw MCMC and relabelling algorithm. The blue line is the estimated density curve.")
}else{
par(mfrow=c(1,1), mar=c(3,3,2,1), oma =c(0,0,0,0))
xy <- y
nbins <- 20
x.bin <- seq(floor(min(xy[,1])),
ceiling(max(xy[,1])), length=nbins)
y.bin <- seq(floor(min(xy[,2])),
ceiling(max(xy[,2])), length=nbins)
freq <-  as.data.frame(table(findInterval(xy[,1],
x.bin),findInterval(xy[,2], y.bin)))
freq[,1] <- as.numeric(freq[,1])
freq[,2] <- as.numeric(freq[,2])
freq2D <- diag(nbins)*0
freq2D[cbind(freq[,1], freq[,2])] <- freq[,3]
#cols <- (freq2D[-1,-1] + freq2D[-1,-(nbins-1)] + freq2D[-(nbins-1),-(nbins-1)] + freq2D[-(nbins-1),-1])/4
res <- persp(x.bin, y.bin,
freq2D,   xlab="\n\n\nx",
ylab="\n\n\ny", zlab="\n\n\nf(x,y)",
theta=30, phi=30,
expand=0.5, ltheta=1,
lphi=1,
col = "white",
#"navajowhite1",
shade = 0.1, ticktype = "detailed",
main= paste("Rel means"), cex.main=1.8,
cex.lab =1.8)
points(trans3d(est[,1],
est[,2], -2,
pmat = res), col = "red", pch = 17,
cex=1.5)
# points(trans3d(est[,1],
#                est[,2], max(freq[,3])+1,
#                pmat = res), col = "red", pch = 16,
#        cex=1.5)
#lines(trans3d(est[,1], est[,2],
#             max(freq[,3])+1, pmat =res), col="red")
cat("Description: 3d histogram of the data along with the posterior estimates of the relabelled means (red points)")
}
}
# else if (type=="iter"){
#   par(mfrow=c(1,1))
#   barplot(n.iter, main="Proportion of valid iterations", ylim=c(0,1),
#           xlab="Pivotal criterion", ylab="Prop.", names.arg=c(1:7))
# }
}
piv_plot(y=sim$y, mcmc=res, rel_est = rel, type="hist")
devtools::document()
library(pivmet)
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
help(piv_sim)
N  <- 2000
k  <- 3
M1 <- c(-45,8)
M2 <- c(45,.1)
M3 <- c(100,8)
Mu <- matrix(rbind(M1,M2,M3),c(k,2))
stdev    <- cbind(rep(1,k), rep(20,k))
Sigma.p1 <- matrix(c( stdev[1,1]^2, 0,0,
stdev[1,1]^2), nrow=2, ncol=2)
Sigma.p2 <- matrix(c(stdev[1,2]^2, 0,0,
stdev[1,2]^2), nrow=2, ncol=2)
W   <- c(0.2,0.8)
sim <- piv_sim(N, k, Mu, Sigma.p1 = Sigma.p1,
Sigma.p2 = Sigma.p2, W)
piv_sim <- function(N,
k,
Mu,
stdev,
Sigma.p1 = matrix(c(1,0,0,1),2,2, byrow = TRUE),
Sigma.p2 = matrix(c(100,0,0,100),2,2, byrow = TRUE),
W = c(0.5, 0.5)){
# Generation---------------
#############
## checks
# W
if (sum(W)!=1){
stop("Check that the sub-weights sum to one!")
}else if(length(W)!=2){
stop("The sub-weight vector should be of dimension two.")
}
# stdev
if(missing(stdev)){
stdev <- cbind(rep(1,k), rep(20,k))
}
if (dim(stdev)[1]!=k){
stop("The number of rows of stdev has to match
with the number of mixture components, k.")
}
# Sigma.p1 and Sigma.p2
if (is.positive.definite(Sigma.p1)==FALSE |
is.positive.definite(Sigma.p2)==FALSE){
stop("Matrix covariances should be positive definite!")
}
# k
if (is.vector(Mu)){
if (k != length(Mu)){
stop("The number of mixture components has to be equal
to the input means length")
}
}else if (is.matrix(Mu)){
if (k != dim(Mu)[1]){
stop("The number of mixture components has to be equal
to the input means length")
}
}
##########
if (is.vector(Mu)){
true.group <- sample(1:k,N,replace=TRUE,prob=rep(1/k,k))
Spike <- array()
matrixpi <- matrix(rep(W,k), nrow=k, ncol=2, byrow = T)
sotto.gruppi <- matrix(0, nrow=k, ncol=N)
y <- c()
for (i in 1:N){
sotto.gruppi[,i] <- sample(1:2, k, replace=T,
prob=matrixpi[true.group[i],])
y[i] <- rnorm(1, mean=Mu[true.group[i]],
sd=stdev[sotto.gruppi[true.group[i],i]])
}
}else{
true.group <- sample(1:k,N,replace=TRUE,prob=rep(1/k,k))
Spike <- array(c(Sigma.p1,Sigma.p2), dim=c(2,2,2))
# Probability matrix of subgroups
matrixpi <- matrix(rep(W,k), nrow=k, ncol=2, byrow = T)
sotto.gruppi <- matrix(0, nrow=k, ncol=N)
for (i in 1:N){
sotto.gruppi[,i] <- sample(1:2,k,replace=T,
prob=matrixpi[true.group[i],])
}
# Simulation of N units from a mixture of mixtures
y <- matrix(NA,nrow=N,ncol=2)
for (i in 1:length(true.group)){
y[i,] <- mvrnorm(1, Mu[true.group[i],],
Sigma=Spike[,,sotto.gruppi[true.group[i],i]])
}
}
return(list(y=y, true.group=true.group, subgroups=sotto.gruppi))
}
N  <- 2000
k  <- 3
M1 <- c(-45,8)
M2 <- c(45,.1)
M3 <- c(100,8)
Mu <- matrix(rbind(M1,M2,M3),c(k,2))
stdev    <- cbind(rep(1,k), rep(20,k))
Sigma.p1 <- matrix(c( stdev[1,1]^2, 0,0,
stdev[1,1]^2), nrow=2, ncol=2)
Sigma.p2 <- matrix(c(stdev[1,2]^2, 0,0,
stdev[1,2]^2), nrow=2, ncol=2)
W   <- c(0.2,0.8)
sim <- piv_sim(N, k, Mu, Sigma.p1 = Sigma.p1,
Sigma.p2 = Sigma.p2, W)
stdev <- cbind(rep(1,k), rep(20,k))
stdev
dim(stdev)[1]
k
dim(stdev)[1]!=k
piv_sim <- function(N,
k,
Mu,
stdev,
Sigma.p1 = matrix(c(1,0,0,1),2,2, byrow = TRUE),
Sigma.p2 = matrix(c(100,0,0,100),2,2, byrow = TRUE),
W = c(0.5, 0.5)){
# Generation---------------
#############
## checks
# W
if (sum(W)!=1){
stop("Check that the sub-weights sum to one!")
}else if(length(W)!=2){
stop("The sub-weight vector should be of dimension two.")
}
# stdev
if(missing(stdev)){
stdev <- cbind(rep(1,k), rep(20,k))
}
if (dim(stdev)[1]!=k){
stop("The number of rows of stdev has to match
with the number of mixture components, k.")
}
# Sigma.p1 and Sigma.p2
if (is.positive.definite(Sigma.p1)==FALSE |
is.positive.definite(Sigma.p2)==FALSE){
stop("Matrix covariances should be positive definite!")
}
# k
if (is.vector(Mu)){
if (k != length(Mu)){
stop("The number of mixture components has to be equal
to the input means length")
}
}else if (is.matrix(Mu)){
if (k != dim(Mu)[1]){
stop("The number of mixture components has to be equal
to the input means length")
}
}
##########
if (is.vector(Mu)){
true.group <- sample(1:k,N,replace=TRUE,prob=rep(1/k,k))
Spike <- array()
matrixpi <- matrix(rep(W,k), nrow=k, ncol=2, byrow = T)
sotto.gruppi <- matrix(0, nrow=k, ncol=N)
y <- c()
for (i in 1:N){
sotto.gruppi[,i] <- sample(1:2, k, replace=T,
prob=matrixpi[true.group[i],])
y[i] <- rnorm(1, mean=Mu[true.group[i]],
sd=stdev[sotto.gruppi[true.group[i],i]])
}
}else{
true.group <- sample(1:k,N,replace=TRUE,prob=rep(1/k,k))
Spike <- array(c(Sigma.p1,Sigma.p2), dim=c(2,2,2))
# Probability matrix of subgroups
matrixpi <- matrix(rep(W,k), nrow=k, ncol=2, byrow = T)
sotto.gruppi <- matrix(0, nrow=k, ncol=N)
for (i in 1:N){
sotto.gruppi[,i] <- sample(1:2,k,replace=T,
prob=matrixpi[true.group[i],])
}
# Simulation of N units from a mixture of mixtures
y <- matrix(NA,nrow=N,ncol=2)
for (i in 1:length(true.group)){
y[i,] <- mvrnorm(1, Mu[true.group[i],],
Sigma=Spike[,,sotto.gruppi[true.group[i],i]])
}
}
return(list(y=y, true.group=true.group, subgroups=sotto.gruppi))
}
N  <- 2000
k  <- 3
M1 <- c(-45,8)
M2 <- c(45,.1)
M3 <- c(100,8)
Mu <- matrix(rbind(M1,M2,M3),c(k,2))
stdev    <- cbind(rep(1,k), rep(20,k))
Sigma.p1 <- matrix(c( stdev[1,1]^2, 0,0,
stdev[1,1]^2), nrow=2, ncol=2)
Sigma.p2 <- matrix(c(stdev[1,2]^2, 0,0,
stdev[1,2]^2), nrow=2, ncol=2)
W   <- c(0.2,0.8)
sim <- piv_sim(N, k, Mu, Sigma.p1 = Sigma.p1,
Sigma.p2 = Sigma.p2, W)
N  <- 2000
k  <- 3
M1 <- c(-45,8)
M2 <- c(45,.1)
M3 <- c(100,8)
Mu <- matrix(rbind(M1,M2,M3),c(k,2))
stdev    <- cbind(rep(1,k), rep(20,k))
Sigma.p1 <- matrix(c( stdev[1,1]^2, 0,0,
stdev[1,1]^2), nrow=2, ncol=2)
Sigma.p2 <- matrix(c(stdev[1,2]^2, 0,0,
stdev[1,2]^2), nrow=2, ncol=2)
W   <- c(0.2,0.8)
sim <- piv_sim(N, k=k, Mu, Sigma.p1 = Sigma.p1,
Sigma.p2 = Sigma.p2, W)
N  <- 2000
k  <- 3
M1 <- c(-45,8)
M2 <- c(45,.1)
M3 <- c(100,8)
Mu <- matrix(rbind(M1,M2,M3),c(k,2))
stdev    <- cbind(rep(1,k), rep(20,k))
Sigma.p1 <- matrix(c( stdev[1,1]^2, 0,0,
stdev[1,1]^2), nrow=2, ncol=2)
Sigma.p2 <- matrix(c(stdev[1,2]^2, 0,0,
stdev[1,2]^2), nrow=2, ncol=2)
W   <- c(0.2,0.8)
sim <- piv_sim(N, k=k, Mu=Mu, Sigma.p1 = Sigma.p1,
Sigma.p2 = Sigma.p2, W=W)
library(corpcor)
N  <- 2000
k  <- 3
M1 <- c(-45,8)
M2 <- c(45,.1)
M3 <- c(100,8)
Mu <- matrix(rbind(M1,M2,M3),c(k,2))
stdev    <- cbind(rep(1,k), rep(20,k))
Sigma.p1 <- matrix(c( stdev[1,1]^2, 0,0,
stdev[1,1]^2), nrow=2, ncol=2)
Sigma.p2 <- matrix(c(stdev[1,2]^2, 0,0,
stdev[1,2]^2), nrow=2, ncol=2)
W   <- c(0.2,0.8)
sim <- piv_sim(N, k=k, Mu=Mu, Sigma.p1 = Sigma.p1,
Sigma.p2 = Sigma.p2, W=W)
library(pivmet)
N  <- 2000
k  <- 3
M1 <- c(-45,8)
M2 <- c(45,.1)
M3 <- c(100,8)
Mu <- matrix(rbind(M1,M2,M3),c(k,2))
stdev    <- cbind(rep(1,k), rep(20,k))
Sigma.p1 <- matrix(c( stdev[1,1]^2, 0,0,
stdev[1,1]^2), nrow=2, ncol=2)
Sigma.p2 <- matrix(c(stdev[1,2]^2, 0,0,
stdev[1,2]^2), nrow=2, ncol=2)
W   <- c(0.2,0.8)
sim <- piv_sim(N, k=k, Mu=Mu, Sigma.p1 = Sigma.p1,
Sigma.p2 = Sigma.p2, W=W)
library(MASS)
N  <- 2000
k  <- 3
M1 <- c(-45,8)
M2 <- c(45,.1)
M3 <- c(100,8)
Mu <- matrix(rbind(M1,M2,M3),c(k,2))
stdev    <- cbind(rep(1,k), rep(20,k))
Sigma.p1 <- matrix(c( stdev[1,1]^2, 0,0,
stdev[1,1]^2), nrow=2, ncol=2)
Sigma.p2 <- matrix(c(stdev[1,2]^2, 0,0,
stdev[1,2]^2), nrow=2, ncol=2)
W   <- c(0.2,0.8)
sim <- piv_sim(N, k=k, Mu=Mu, Sigma.p1 = Sigma.p1,
Sigma.p2 = Sigma.p2, W=W)
devtools::document()
devtools::check()
help(piv_KMeans)
devtools::document()
devtools::check()
devtools::install_github("leoegidi/pivmet")
sessionInfo()
help("MUS")
help("piv_KMeans")
setwd("~/GitHub/pivmet")
library(pivmet)
devtools::document()
devtools::check()
devtools::document()
library(pivmet)
help("plot")
devtools::document()
library(pivmet)
devtools::document()
library(pivmet)
devtools::document()
devtools::check()
devtools::document()
devtools::check()
library(pivmet)
devtools::document()
