# Switching Post
cont <- 0
for (l in verigruppi){
cont <- cont+1
group.orig[group==l] <- cont
}
k.orig <- k
if (cont > 1){
k <- cont
}
mu_switch <- array(rep(0, true.iter*2*k), dim=c(true.iter,2,k))
group <- group*0
z <- array(0,dim=c(N, k, true.iter))
for (i in 1:true.iter){
perm <- sample(1:k,k,replace=FALSE)
for (j in 1:k){
#post-processing
group[i,group.orig[i,]==j] <- perm[j]
}
mu_switch[i,,] <- mu_pre_switch[i,,perm]
#tau[i,] <- tau[i,perm]
prob.st[i,] <- prob.st[i,perm]
}
for (i in 1:true.iter){
for (j in 1:N){
z[j,group[i,j],i] <- 1
}
}
}
FreqGruppiJagsPERM <- table(group)
Freq <- cbind(FreqGruppiJags,FreqGruppiJagsPERM)
colnames(Freq) <- c("JAGS raw groups", "JAGS post-processed groups")
# Similarity matrix based on MCMC sampling------------------------
nz <- dim(z)[1]
M <- dim(z)[3]
C <- matrix(1,nz,nz)
zm <- apply(z,c(1,3),FUN=function(x) sum(x*(1:length(x))))
for (i in 1:(nz-1)){
for (j in (i+1):nz){
C[i,j] <- sum(zm[i,]==zm[j,])/M
C[j,i] <- C[i,j]
}
}
matdissim <- 1-C
diag(matdissim) <- 0
# Clustering on dissimilarity matrix-------------
if (missing(clustering)){
#clustering <- "diana"
gr  <- diana(matdissim,diss=TRUE)
grr <- cutree(gr, k)
}else if(clustering =="diana"){
gr  <- diana(matdissim,diss=TRUE)
grr <- cutree(gr, k)
}else if(clustering == "hclust"){
gr  <- hclust(as.dist(matdissim))
grr <- cutree(gr, k)
}
available_met <- 3
piv.criterion.choices <- c("maxsumint", "maxsumnoint",
"maxsumdiff")
if (missing(piv.criterion)){
piv.criterion <- "maxsumdiff"
}
if (piv.criterion=="maxsumint"||
piv.criterion=="maxsumnoint"||
piv.criterion=="maxsumdiff" ){
piv.index <- (1:3)[piv.criterion.choices==piv.criterion]
piv.index.pivotal <- c(1,2,3)
available_met <- 3
x <- c(1:available_met)
prec.par.1 <- min(min(table(grr))-1,5)
clust  <-  piv_sel(C=C, clusters=as.vector(grr))
pivots <- clust$pivots[,piv.index.pivotal[piv.index]]
}else if(piv.criterion=="MUS"){
if (k <=4 & sum(C==0)!=0){
prec.par.1 <- min(min(table(grr))-1,5)
mus_res    <- MUS(C, grr, prec.par.1)
clust  <-  mus_res$pivots
}else{
print("maxsumdiff criterion instead of MUS has been adopted due to
computational efficiency")
clust  <-  piv_sel(C=C,  clusters=as.vector(grr))
pivots <- clust$pivots[,3]
}
}
return(list( Freq=Freq, true.iter = true.iter, z=z, Mu = mu_inits,
ris=ris, groupPost=group,
mu_switch=mu_switch,
mu_raw=mu_pre_switch_compl,
C=C, grr=grr, pivots = pivots,
piv.criterion = piv.criterion))
}
N   <- 250
nMC <- 2500
k   <- 3
p   <- rep(1/k,k)
x   <- 3
stdev <- cbind(rep(1,k), rep(200,k))
Mu    <- seq(-trunc(k/2)*x,trunc(k/2)*x,length=k)
W     <- c(0.2,0.8)
sim   <- piv_sim(N,k,Mu,stdev,W=W)
res   <- piv_MCMC(sim$y, k, nMC=nMC)
N   <- 250
nMC <- 2500
k   <- 3
p   <- rep(1/k,k)
x   <- 3
stdev <- cbind(rep(1,k), rep(200,k))
Mu    <- seq(-trunc(k/2)*x,trunc(k/2)*x,length=k)
W     <- c(0.2,0.8)
sim   <- piv_sim(N,k,Mu,stdev,W=W)
res   <- piv_MCMC(sim$y, k, nMC)
piv_MCMC <- function(y,
k,
priors,
nMC,
piv.criterion = c("MUS", "maxsumint", "maxsumnoint", "maxsumdiff"),
clustering = c("diana", "hclust")){
# Conditions about data dimension----------------
if (is.vector(y)){
if (missing(priors)){
priors = list(kind = "independence", parameter = "priorsFish",
hierarchical = "tau")
}
N <- length(y)
# JAGS code------------------------
# Initial values
mu_inits<- c()
clust_inits <- kmeans(y, k)$cluster
for (j in 1:k){
mu_inits[j]<-mean(y[clust_inits==j])
}
# Data
burn <- 1000
# Model
mod.mist.univ <- BMMmodel(y, k = k, initialValues = list(S0 = 2),
priors = priors)
control <- JAGScontrol(variables = c("mu", "tau", "eta", "S"),
burn.in = burn, n.iter = nMC, seed = 10)
ogg.jags <- JAGSrun(y, model = mod.mist.univ, control = control)
# Parameters' initialization
J <- 3
mcmc.pars <- array(data = NA, dim = c(nMC-length(1:burn), k, J))
mcmc.pars[ , , 1] <- ogg.jags$results[-(1:burn), (N+k+1):(N+2*k)]
mcmc.pars[ , , 2] <- ogg.jags$results[-(1:burn), (N+2*k+1):(N+3*k)]
mcmc.pars[ , , 3] <- ogg.jags$results[-(1:burn), (N+1):(N+k)]
mu_pre_switch_compl <-  mcmc.pars[ , , 1]
tau_pre_switch_compl <-  mcmc.pars[ , , 2]
prob.st_pre_switch_compl <-  mcmc.pars[ , , 3]
mu <- mcmc.pars[,,1]
tau <- mcmc.pars[,,2]
prob.st <- mcmc.pars[,,3]
group <-  ogg.jags$results[-(1:burn), 1:N] #gruppi
FreqGruppiJags <- table(group)
numeffettivogruppi <- apply(group,1,FUN = function(x) length(unique(x)))
if (sum(numeffettivogruppi==k)==0){
return(print("MCMC has not never been able to identify the required number of groups and the process has been interrupted"))
#return(1)
}
##saved in the output
ris_prel <- ogg.jags$results[-(1:burn),]
ris <- ris_prel[numeffettivogruppi==k,]
true.iter <- nrow(ris)
group <- ris[,1:N]
group.orig <- group
verigruppi <- as.double(names(table(group)))
cont <- 0
for (verogruppo in verigruppi){
cont <- cont+1
group.orig[group==verogruppo] <- cont          #aggiorna contatore pivot
}
cont                                           #qualche dubbio su sta parte
k.orig <- k
if (cont>1){
k <- cont
}
mu <- mu[,verigruppi]
tau <- tau[,verigruppi]
prob.st <- prob.st[,verigruppi]
M <- nrow(group)
group <- group*0
mu_switch <- array(rep(0, true.iter*k), dim=c(true.iter,k))
z <- array(0,dim=c(N, k, true.iter))
for (i in 1:true.iter){
perm <- sample(1:k,k,replace=FALSE)
for (j in 1:k){
#post-processing
group[i,group.orig[i,]==j] <- perm[j]
}
mu_switch[i,] <- mu[i,perm]
tau[i,] <- tau[i,perm]
prob.st[i,] <- prob.st[i,perm]
}
for (i in 1:true.iter){
for (j in 1:N){
z[j,group[i,j],i] <- 1
}
}
}else if (is.matrix(y)){
N <- dim(y)[1]
# JAGS code------------------------
# Initial values
mu0 <- as.vector(c(0,0))
S2 <- matrix(c(1,0,0,1),nrow=2)/100000
S3 <- matrix(c(1,0,0,1),nrow=2)/100000
# Data
dati.biv <- list(y = y, N = N, k = k, S2= S2, S3= S3, mu0=mu0,
onesRepNclust = rep(1,k))
# Model
mod.mist.biv<-"model{
# Likelihood:
for (i in 1:N){
yprev[i,1:2]<-y[i,1:2]
y[i,1:2] ~ dmnorm(muOfClust[clust[i],],tauOfClust)
clust[i] ~ dcat(pClust[1:k] )
}
# Prior:
for (g in 1:k) {
muOfClust[g,1:2] ~ dmnorm(mu0[],S2[,])}
tauOfClust[1:2,1:2] ~ dwish(S3[,],3)
Sigma[1:2,1:2] <- inverse(tauOfClust[,])
pClust[1:k] ~ ddirch( onesRepNclust)
}"
# Parameters' initialization
clust_inits <- KMeans(y, k)$cluster
#cutree(hclust(dist(y), "average"),k)
mu_inits <- matrix(0,k,2)
for (j in 1:k){
mu_inits[j,] <- cbind(mean(y[clust_inits==j,1]), mean(y[clust_inits==j,2]))
}
#Reorder mu_inits according to the x-coordinate
mu_inits <-
mu_inits[sort(mu_inits[,1], decreasing=FALSE, index.return=TRUE)$ix,]
init1.biv <- dump.format(list(muOfClust=mu_inits,
tauOfClust= matrix(c(15,0,0,15),ncol=2),
pClust=rep(1/k,k), clust=clust_inits))
moni.biv <- c("clust","muOfClust","tauOfClust","pClust")
mod   <- mod.mist.biv
dati  <- dati.biv
init1 <- init1.biv
moni  <- moni.biv
# Jags execution
ogg.jags <- run.jags(model=mod, data=dati, monitor=moni,
inits=init1, n.chains=3,plots=FALSE, thin=1,
sample=nMC, burnin=1000)
# Extraction
ris <- ogg.jags$mcmc[[1]]
# Post- process of the chains----------------------
group <- ris[,grep("clust[",colnames(ris),fixed=TRUE)]
M <- nrow(group)
H <- list()
mu_pre_switch_compl <- array(rep(0, M*2*k), dim=c(M,2,k))
for (i in 1:k){
H[[i]] <- ris[,grep("muOfClust",colnames(ris),fixed=TRUE)][,c(i,i+k)]
}
for (i in 1:k){
mu_pre_switch_compl[,,i] <- as.matrix(H[[i]])
}
# Discard iterations
numeffettivogruppi <- apply(group,1,FUN = function(x) length(unique(x)))
ris <- ris[numeffettivogruppi==k,]
true.iter <- nrow(ris)
if (sum(numeffettivogruppi==k)==0){
return(print("MCMC has not never been able to identify the required number of groups and the process has been interrupted"))
#return(1)
}else{
L<-list()
mu_pre_switch <- array(rep(0, true.iter*2*k), dim=c(true.iter,2,k))
for (i in 1:k){
L[[i]] <- ris[,grep("muOfClust",colnames(ris),fixed=TRUE)][,c(i,i+k)]
}
for (i in 1:k){
mu_pre_switch[,,i] <- as.matrix(L[[i]])
}
}
group <- ris[,grep("clust[",colnames(ris),fixed=TRUE)]
FreqGruppiJags <- table(group)
tau <- ris[,grep("tauOfClust[",colnames(ris),fixed=TRUE)]
prob.st <- ris[,grep("pClust[",colnames(ris),fixed=TRUE)]
group.orig <- group
verigruppi <- as.double(names(table(group)))
prob.st <- prob.st[,verigruppi]
mu_pre_switch <- mu_pre_switch[,,verigruppi]
# Switching Post
cont <- 0
for (l in verigruppi){
cont <- cont+1
group.orig[group==l] <- cont
}
k.orig <- k
if (cont > 1){
k <- cont
}
mu_switch <- array(rep(0, true.iter*2*k), dim=c(true.iter,2,k))
group <- group*0
z <- array(0,dim=c(N, k, true.iter))
for (i in 1:true.iter){
perm <- sample(1:k,k,replace=FALSE)
for (j in 1:k){
#post-processing
group[i,group.orig[i,]==j] <- perm[j]
}
mu_switch[i,,] <- mu_pre_switch[i,,perm]
#tau[i,] <- tau[i,perm]
prob.st[i,] <- prob.st[i,perm]
}
for (i in 1:true.iter){
for (j in 1:N){
z[j,group[i,j],i] <- 1
}
}
}
FreqGruppiJagsPERM <- table(group)
Freq <- cbind(FreqGruppiJags,FreqGruppiJagsPERM)
colnames(Freq) <- c("JAGS raw groups", "JAGS post-processed groups")
# Similarity matrix based on MCMC sampling------------------------
nz <- dim(z)[1]
M <- dim(z)[3]
C <- matrix(1,nz,nz)
zm <- apply(z,c(1,3),FUN=function(x) sum(x*(1:length(x))))
for (i in 1:(nz-1)){
for (j in (i+1):nz){
C[i,j] <- sum(zm[i,]==zm[j,])/M
C[j,i] <- C[i,j]
}
}
matdissim <- 1-C
diag(matdissim) <- 0
# Clustering on dissimilarity matrix-------------
if (missing(clustering)){
#clustering <- "diana"
gr  <- diana(matdissim,diss=TRUE)
grr <- cutree(gr, k)
}else if(clustering =="diana"){
gr  <- diana(matdissim,diss=TRUE)
grr <- cutree(gr, k)
}else if(clustering == "hclust"){
gr  <- hclust(as.dist(matdissim))
grr <- cutree(gr, k)
}
available_met <- 3
piv.criterion.choices <- c("maxsumint", "maxsumnoint",
"maxsumdiff")
if (missing(piv.criterion)){
piv.criterion <- "maxsumdiff"
}
if (piv.criterion=="maxsumint"||
piv.criterion=="maxsumnoint"||
piv.criterion=="maxsumdiff" ){
piv.index <- (1:3)[piv.criterion.choices==piv.criterion]
piv.index.pivotal <- c(1,2,3)
available_met <- 3
x <- c(1:available_met)
prec.par.1 <- min(min(table(grr))-1,5)
clust  <-  piv_sel(C=C, clusters=as.vector(grr))
pivots <- clust$pivots[,piv.index.pivotal[piv.index]]
}else if(piv.criterion=="MUS"){
if (k <=4 & sum(C==0)!=0){
prec.par.1 <- min(min(table(grr))-1,5)
mus_res    <- MUS(C, grr, prec.par.1)
clust  <-  mus_res$pivots
}else{
print("maxsumdiff criterion instead of MUS has been adopted due to
computational efficiency")
clust  <-  piv_sel(C=C,  clusters=as.vector(grr))
pivots <- clust$pivots[,3]
}
}
return(list( Freq=Freq, true.iter = true.iter, z=z, Mu = mu_inits,
ris=ris, groupPost=group,
mu_switch=mu_switch,
mu_raw=mu_pre_switch_compl,
C=C, grr=grr, pivots = pivots,
piv.criterion = piv.criterion))
}
N   <- 250
nMC <- 2500
k   <- 3
p   <- rep(1/k,k)
x   <- 3
stdev <- cbind(rep(1,k), rep(200,k))
Mu    <- seq(-trunc(k/2)*x,trunc(k/2)*x,length=k)
W     <- c(0.2,0.8)
sim   <- piv_sim(N,k,Mu,stdev,W=W)
res   <- piv_MCMC(sim$y, k, nMC=nMC)
1/100000
1e+05
priors = list(mu0 = c(0,0), S2= matrix(c(1,0,0,1), 2,2,byrow=T), S3 = matrix(c(100,0,0,100), 2,2,byrow=TRUE))
priors
devtools::document()
library(pivmet)
help("piv_MCMC")
devtools::document()
library(pivmet)
help("piv_MCMC")
N   <- 200
k   <- 4
nMC <- 1000
M1  <-c(-.5,8)
M2  <- c(25.5,.1)
M3  <- c(49.5,8)
M4  <- c(63.0,.1)
Mu  <- matrix(rbind(M1,M2,M3,M4),c(4,2))
stdev    <- cbind(rep(1,k), rep(200,k))
Sigma.p1 <- matrix(c(stdev[1,1],0,0,stdev[1,1]), nrow=2, ncol=2)
Sigma.p2 <- matrix(c(stdev[1,2],0,0,stdev[1,2]), nrow=2, ncol=2)
W <- c(0.2,0.8)
sim <- piv_sim(N,k,Mu, stdev, Sigma.p1,Sigma.p2,W)
res <- piv_MCMC(y = sim$y, k =k, nMC = nMC)
#changing priors
res2 <- piv_MCMC(y = sim$y,
priors = list (
mu0=c(1,1),
S2 = matrix(c(0.002,0,0, 0.1),2,2, byrow=TRUE),
S3 = matrix(c(0.1,0,0,0.1), 2,2, byrow =TRUE)),
k = k, nMC = nMC)
data(fish)
y <- fish[,1]
k <- 5
nMC <- 5000
res <- piv_MCMC(y = y, k = k, nMC = nMC)
# changing priors
res2   <- piv_MCMC(y = y,
priors = list(kind = "conditionallyconjugate",
parameter = "priorsRaftery",
hierarchical = "tau"),  k =k, nMC = nMC)
res2   <- piv_MCMC(y = y,
priors = list(kind = "condconjugate",
parameter = "priorsRaftery",
hierarchical = "tau"),  k =k, nMC = nMC)
N   <- 250
nMC <- 2500
k   <- 3
p   <- rep(1/k,k)
x   <- 3
stdev <- cbind(rep(1,k), rep(200,k))
Mu    <- seq(-trunc(k/2)*x,trunc(k/2)*x,length=k)
W     <- c(0.2,0.8)
sim   <- piv_sim(N,k,Mu,stdev,W=W)
res   <- piv_MCMC(y = sim$y, k =k, nMC = nMC)
rel   <- piv_rel(mcmc=res, nMC = nMC)
N <- 200
k <- 3
nMC <- 5000
M1  <- c(-.5,8)
M2  <- c(25.5,.1)
M3  <- c(49.5,8)
Mu  <- matrix(rbind(M1,M2,M3),c(k,2))
stdev <- cbind(rep(1,k), rep(200,k))
Sigma.p1 <- matrix(c(stdev[1,1],0,0,stdev[1,1]),
nrow=2, ncol=2)
Sigma.p2 <- matrix(c(stdev[1,2],0,0,stdev[1,2]),
nrow=2, ncol=2)
W <- c(0.2,0.8)
sim <- piv_sim(N,k,Mu,stdev,Sigma.p1,Sigma.p2,W)
res <- piv_MCMC(y = sim$y, k = k, nMC = nMC)
rel <- piv_rel(mcmc = res, nMC = nMC)
piv_plot(y=sim$y, mcmc=res, rel_est = rel, type="chains")
piv_plot(y=sim$y, mcmc=res, rel_est = rel,
type="hist")
devtools::document()
library(pivmet)
system("R CMD Rd2pdf C:/Users/leoeg/OneDrive/Documenti/GitHub/pivmet/R")
system("R CMD Rd2pdf C:/Users/leoeg/OneDrive/Documenti/GitHub/pivmet")
system("R CMD Rd2pdf C:/Users/leoeg/OneDrive/Documenti/GitHub/pivmet")
system("R CMD Rd2pdf C:/Users/leoeg/OneDrive/Documenti/GitHub/pivmet")
devtools::document()
library(pivmet)
system("R CMD Rd2pdf C:/Users/leoeg/OneDrive/Documenti/GitHub/pivmet")
help("Rd2pdf")
devtools::document()
library(pivmet)
system("R CMD Rd2pdf C:/Users/leoeg/OneDrive/Documenti/GitHub/pivmet")
devtools::document()
library(pivmet)
system("R CMD Rd2pdf C:/Users/leoeg/OneDrive/Documenti/GitHub/pivmet")
devtools::document()
devtools::document()
devtools::document()
devtools
devtools::document()
devtools::document()
library(pivmet)
devtools::document()
library(pivmet)
system("R CMD Rd2pdf C:/Users/leoeg/OneDrive/Documenti/GitHub/pivmet")
devtools::document()
library(pivmet)
system("R CMD Rd2pdf C:/Users/leoeg/OneDrive/Documenti/GitHub/pivmet")
dim(res$z)
res$true.iter
devtools::document()
library(pivmet)
system("R CMD Rd2pdf C:/Users/leoeg/OneDrive/Documenti/GitHub/pivmet")
rel$mu_rel_complete
dim(rel$mu_rel_complete)
rel$Final_It
nMC
154/5000
devtools::document()
library(pivmet)
system("R CMD Rd2pdf C:/Users/leoeg/OneDrive/Documenti/GitHub/pivmet")
library(shiny); runApp('C:/Users/leoeg/Dropbox/quizshiny/AnalisiResidui.R')
devtools::document()
library(pivmet)
system("R CMD Rd2pdf C:/Users/leoeg/OneDrive/Documenti/GitHub/pivmet")
library(pivmet)
help("MUS")
library(pivmet)
devtools::document()
library(pivmet)
system("R CMD Rd2pdf C:/Users/leoeg/OneDrive/Documenti/GitHub/pivmet")
