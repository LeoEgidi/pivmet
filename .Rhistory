#
#     for (j in 2:6){
#     hist(y, breaks=40, prob = TRUE,
#     main=
#     paste("Real data and relabelled estimates (", pivotal.criterion[j], ")" ) )
#     points(est[,pivotal.criterion[j]], rep(0, length(true.means)),
#       col="red", pch=21,  bg="red")
#     }
#
#     }
else if (type=="iter"){
par(mfrow=c(1,1))
barplot(n.iter, main="Proportion of valid iterations", ylim=c(0,1),
xlab="Pivotal criterion", ylab="Prop.", names.arg=c(1:7))
}
}
piv_plot(y=sim$y, mcmc=res, rel_est = rel,
type="estimates")
library(pivmet)
piv_plot(y=sim$y, mcmc=res, rel_est = rel,
type="estimates")
devtools::document()
library(pivmet)
piv_plot(y=sim$y, mcmc=res, rel_est = rel,
type="estimates")
piv_plot <- function(y, mcmc, rel_est, type ){
colori <- c("red", "green", "violet", "blue")
est <- rel_est$mu_rel_median
chains <- rel_est$mu_rel_complete
mu_switch <- mcmc$mu_switch
n.iter <- rel_est$Final_It
true.means <- mcmc$Mu
if (type=="chains" ){
if (length(dim(mu_switch))==2){
k <- dim(mu_switch)[2]
par(mfrow=c(1,2), oma=c(0,0,0,0))
#plot
matplot(mu_switch, type="l", xlab="Iterations",
ylab=expression(mu), main="Raw MCMC chains",
cex.main=0.8)
#plot the relabeled
matplot(chains, type="l",
xlab="Iterations",
ylab=expression(mu),
main=paste("Rel. chains"), cex.main=0.8)
}else{
k <- dim(mu_switch)[3]
par(mfrow=c(2,2), oma=c(0,0,0,0))
matplot(mu_switch[,1,], type="l", xlab="Iterations",
ylab=expression(mu[1]), main="Raw MCMC chains",
cex.main=0.8 )
#plot the second component
matplot(mu_switch[,2,], type="l", xlab="Iterations",
ylab=expression(mu[2]), main="Raw MCMC chains",
cex.main=0.8)
#plot the first relabelled component
matplot(chains[,1,],type="l", xlab="Iterations",
ylab=expression(mu[1]),
main=paste("Rel.chains"), cex.main=0.8)
#plot the second relabelled component
matplot(chains[,2,],type="l", xlab="Iterations",
ylab=expression(mu[2]),
main=paste("Rel. chains"), cex.main=0.8)
}
}
#else if(type=="chains" & all(pivotal.criterion, c(1:6))){
#   if (length(dim(mu_switch))==2){
#
#     k <- dim(mu_switch)[2]
#     par(mfrow=c(3,2), oma=c(0,0,0,0))
#
#     #plot the relabeled
#     for (j in 1:6){
#     matplot(chains[[pivotal.criterion[j]]], type="l",
#       xlab="Iterations",
#       ylab=expression(mu),
#       main=paste("Relabelled chains: method", pivotal.criterion[j]))
#     }
#
#   }else{
#     par(mfrow=c(3,4))
#
#     for (j in 1:6){
#     #plot the first relabelled component
#     matplot(chains[[pivotal.criterion[j]]][,1,],type="l",
#       xlab="Iterations",
#       ylab=expression(mu[1]),
#       main=paste("Rel. method ", pivotal.criterion[j]))
#
#     #plot the second relabelled component
#     matplot(chains[[pivotal.criterion[j]]][,2,],type="l",
#       xlab="Iterations",
#       ylab=expression(mu[2]),
#       main=paste("Rel. method ", pivotal.criterion[j]) )
#     }
#
#   }
#
#
#}
else if (type=="estimates"){
if (length(dim(mu_switch))==2){
switch.means <- colMeans(mu_switch)
par(mfrow=c(1,2), oma=c(0,0,0,0), las=1, yaxt="n")
# raw estimates
plot( true.means, rep(0.3,length(true.means)),
axes = FALSE , ylab="",ylim=c(0,1),
xlim=c( min(true.means,
est)-2,
max(true.means,
est)+2  ),
main=paste("Raw MCMC estimates" ), cex.main =0.8)
points(switch.means,
rep(0, length(true.means)), col="red")
axis(1)
axis(1, col = "black", tcl = 0)
par(yaxt="n")
axis(2)
par(yaxt="s")
axis(2, c(0,0.3), c("Est.", "True"), col = "white", tcl = 0)
#relabelled estimates
plot( true.means, rep(0.3,length(true.means)),
axes = FALSE , ylab="",ylim=c(0,1),
xlim=c( min(true.means,
est)-2,
max(true.means,
est)+2  ),
main=paste("Rel. estimates"), cex.main =0.8)
points(est, rep(0, length(true.means)),
col="red")
axis(1)
axis(1, col = "black", tcl = 0)
par(yaxt="n")
axis(2)
par(yaxt="s")
axis(2, c(0,0.3), c("Est.", "True"), col = "white", tcl = 0)
}else{
par(mfrow=c(1,2), oma =c(0,0,0,0))
colori<-c("red", "green", "violet", "blue")
l1<-(3/2)*min(true.means[,1])-max(true.means[,1])/2+5
l2<-(3/2)*max(true.means[,1])-min(true.means[,1])/2-5
u1<-(3/2)*min(true.means[,2])-max(true.means[,2])/2
u2<-(3/2)*max(true.means[,2])-min(true.means[,2])/2
#plot the raw MCMC estimates
plot(true.means, xlim=c( min(true.means, est)-2,
max(true.means,est)+2  ),
ylim=c(u1,u2), main="Raw MCMC output",
xlab=expression(mu[1]), ylab=expression(mu[2]), pch =3)
points(t(apply(mu_switch, c(2,3), mean)), col="red")
#for (j in 1:k)
# points(output_bayes$mu_switch[,,j], col=colori[j])
#plot relabelled estimates
plot(true.means, xlim=c( min(true.means, est)-1,
max(true.means, est)+1  ), ylim=c(u1,u2),
xlab=expression(mu[1]), ylab=expression(mu[2]),
main="Relabelled",  pch=3, bg=2)
points(est, col="red")
}
}else if(type=="estimates_hist"){
if (length(dim(mu_switch))==2){
par(mfrow=c(1,2))
hist(y, breaks=40, prob = TRUE,
main ="Raw MCMC estimates", cex.main =0.8)
points(colMeans(mu_switch), rep(0, length(true.means)),
col="red", pch=21,  bg="red")
hist(y, breaks=40, prob = TRUE,
main=paste("Rel. estimates" ), cex.main=0.8 )
points(est, rep(0, length(true.means)),
col="red", pch=21,  bg="red")
}else{
par(mfrow=c(1,1), mar=c(3,3,2,1), oma =c(1,1,1,1))
#   NBiv_mix <- function(x, y, k, rho, mu_x, mu_y,
#     sigma_1x, sigma_1y, sigma_2x,sigma_2y, p){
#     a <- (2*pi*sigma_1x*sigma_1y*sqrt(1-rho^2))^(-1)
#     a2 <- (2*pi*sigma_2x*sigma_2y*sqrt(1-rho^2))^(-1)
#     distr <- list()
#     for (j in 1:k){
#     distr[[j]] <-
#     p*a*exp(-.5*(1)*(1-rho^2)^(-1)*
#         ( ( (x-mu_x[j])/sigma_1x )^2+
#             ((y-mu_y[j])/sigma_1y)^2
#             -2*rho*(x-mu_x[j])*(y-mu_y[j])/
#             (sigma_1x*sigma_1y)   ))+
#             (1-p)*a2*exp(-.5*(1)*(1-rho^2)^(-1)*
#             ( ( (x-mu_x[j])/sigma_2x )^2+
#             ((y-mu_y[j])/sigma_2y)^2
#             -2*rho*(x-mu_x[j])*(y-mu_y[j])/
#             (sigma_2x*sigma_2y)   ))
# }
#
#     sum_vec <- matrix(NA, k, length(distr[[j]]))
#     for (j in 1:k){
#       sum_vec[j,] <- as.vector(distr[[j]])
#     }
#
#     return(apply(sum_vec,2,sum))
#
#     }
#
#   xx<-seq(min(y[,1])-1, max(y[,1])+1, length.out = min(100, length(y[,1])/2))
#   yy<-seq(min(y[,2])-1, max(y[,2])+1, length.out = min(100, length(y[,1])/2))
#   mu_x=add[,1]
#   mu_y=add[,2]
#   # poniamo rho=1/2
#   par(mfrow=c(1,1), oma= c(0,0,0,0))
#   z<-outer(xx, yy, NBiv_mix, k = length(add[,1]),
#     mu_x=mu_x, mu_y=mu_y, sigma_1x= add2[1], sigma_1y=add2[2],
#     sigma_2x=add2[3], sigma_2y=add2[4], p =add2[5], rho=0.5)
#   #Raw MCMC
#   persp(xx, yy, z, theta=30, phi=30, xlab="x", ylab="y", zlab="f(x,y)",
#     expand=0.5, ltheta=120,
#     col = "lightblue", shade = 0.1, ticktype = "detailed" ) -> res
#   points(trans3d(t(apply(mu_switch, c(2,3), mean))[,1],
#     t(apply(mu_switch, c(2,3), mean))[,2], 0, pmat = res), col = 2, pch = 16)
#   #Relabelled
#    persp(xx, yy, z, theta=30, phi=30, xlab="x", ylab="y", zlab="f(x,y)",
#     expand=0.5, ltheta=120,
#      col = "lightblue",
#      shade = 0.1, ticktype = "detailed",
#      main=
#        paste("Rel. estimates: method ",
#          pivotal.criterion), cex.main=0.8) -> res
#    points(trans3d(est[,1,pivotal.criterion],
#      est[,2,pivotal.criterion], 0, pmat = res), col = 2, pch = 16)
# 3d histogram
xy <- y
nbins <- 20
x.bin <- seq(floor(min(xy[,1])),
ceiling(max(xy[,1])), length=nbins)
y.bin <- seq(floor(min(xy[,2])),
ceiling(max(xy[,2])), length=nbins)
freq <-  as.data.frame(table(findInterval(xy[,1],
x.bin),findInterval(xy[,2], y.bin)))
freq[,1] <- as.numeric(freq[,1])
freq[,2] <- as.numeric(freq[,2])
freq2D <- diag(nbins)*0
freq2D[cbind(freq[,1], freq[,2])] <- freq[,3]
#par(mfrow=c(1,2))
#image(x.bin, y.bin, freq2D,
#col=topo.colors(max(freq2D)))
#contour(x.bin, y.bin, freq2D,
#add=TRUE, col=rgb(1,1,1,.7))
#palette(rainbow(max(freq2D)))
#cols <- (freq2D[-1,-1] +
#freq2D[-1,-(nbins-1)] +
# freq2D[-(nbins-1),-(nbins-1)] +
#freq2D[-(nbins-1),-1])/4
res <- persp(x.bin, y.bin,
freq2D, theta=30, phi=30, xlab="\n\n\nx",
ylab="\n\n\ny", zlab="\n\n\nf(x,y)",
expand=0.5, ltheta=120,
col = "lightblue",
shade = 0.1, ticktype = "detailed",
main=
paste("Rel. estimates"), cex.main=0.8)
points(trans3d(est[,1],
est[,2], 0,
pmat = res), col = "red", pch = 16)
}
}
# else if(type=="estimates_hist" & all(pivotal.criterion, c(1:6))){
#     par(mfrow=c(3,2))
#     hist(y, breaks=40, prob = TRUE,
#       main=
#       paste("Real data and relabelled estimates (", pivotal.criterion[1], ")" ) )
#       points(est[,pivotal.criterion[1]], rep(0, length(true.means)),
#       col="red", pch=21,  bg="red")
#
#     for (j in 2:6){
#     hist(y, breaks=40, prob = TRUE,
#     main=
#     paste("Real data and relabelled estimates (", pivotal.criterion[j], ")" ) )
#     points(est[,pivotal.criterion[j]], rep(0, length(true.means)),
#       col="red", pch=21,  bg="red")
#     }
#
#     }
else if (type=="iter"){
par(mfrow=c(1,1))
barplot(n.iter, main="Proportion of valid iterations", ylim=c(0,1),
xlab="Pivotal criterion", ylab="Prop.", names.arg=c(1:7))
}
}
piv_plot(y=sim$y, mcmc=res, rel_est = rel,
type="estimates")
library(pivmet)
N  <- 200
k  <- 3
nMC <- 2000
M1 <- c(-45,8)
M2 <- c(45,.1)
M3 <- c(100,8)
Mu <- matrix(rbind(M1,M2,M3),c(k,2))
stdev    <- cbind(rep(1,k), rep(200,k))
Sigma.p1 <- matrix(c(stdev[1,1],0,0,stdev[1,1]),
nrow=2, ncol=2)
Sigma.p2 <- matrix(c(stdev[1,2],0,0,stdev[1,2]),
nrow=2, ncol=2)
W   <- c(0.2,0.8)
sim <- piv_sim(N = N, k = k, Mu = Mu,
stdev = stdev, Sigma.p1 = Sigma.p1, Sigma.p2 = Sigma.p2, W = W)
plot(sim$y, xlab="y[,1]", ylab="y[,2]")
piv_plot(y = y, mcmc = res, rel_est = rel, type = "chains")
piv_plot(y = y, mcmc = res, rel_est = rel, type = "estimates")
piv_plot(y = y, mcmc = res, rel_est = rel, type = "estimates_hist")
par(mfrow=c(1,1,))
par(mfrow=c(1,1))
devtools::document()
library(pivmet)
N <- 200
k <- 3
nMC <- 5000
M1  <- c(-.5,8)
M2  <- c(25.5,.1)
M3  <- c(49.5,8)
Mu  <- matrix(rbind(M1,M2,M3),c(k,2))
stdev <- cbind(rep(1,k), rep(200,k))
Sigma.p1 <- matrix(c(stdev[1,1],0,0,stdev[1,1]),
nrow=2, ncol=2)
Sigma.p2 <- matrix(c(stdev[1,2],0,0,stdev[1,2]),
nrow=2, ncol=2)
W <- c(0.2,0.8)
sim <- piv_sim(N,k,Mu,stdev,Sigma.p1,Sigma.p2,W)
res <- piv_MCMC(sim$y, k, nMC)
rel <- piv_rel(mcmc = res, nMC = nMC)
piv_plot(y=sim$y, mcmc=res, rel_est = rel, type="chains")
piv_plot(y=sim$y, mcmc=res, rel_est = rel,
type="estimates_hist")
piv_plot(y=sim$y, mcmc=res, rel_est = rel,
type="estimates")
piv_plot(y = y, mcmc = res, rel_est = rel, type = "chains")
par(mar=c(5,5,1,1))
piv_plot(y = y, mcmc = res, rel_est = rel, type = "chains")
devtools::document()
library(pivmet)
piv_plot(y=sim$y, mcmc=res, rel_est = rel, type="chains")
piv_plot(y=sim$y, mcmc=res, rel_est = rel,
type="estimates_hist")
piv_plot(y=sim$y, mcmc=res, rel_est = rel, type="chains")
piv_plot(y=sim$y, mcmc=res, rel_est = rel,
type="estimates")
plot(c(1,1))
par(bty="c")
plot(c(1,1))
par(bty=1)
par(bty="1")
par(bty="l")
plot(c(1,1))
par(bty="7")
plot(c(1,1))
par(bty="c")
plot(c(1,1))
par(bty="u")
plot(c(1,1))
devtools::document()
library(pivmet)
library(pivmet)
devtools::document()
library(pivmet)
devtools::document()
library(pivmet)
devtools:document()
devtools::document()
library(pivmet)
devtools::document()
library(pivmet)
devtools::document()
library(pivmet)
par(mfrow=c(1,2))
plot(c(1,1))
plot(c(1,1))
par(mfrow=c(1,2), oma =c(5,5,5,5))
plot(c(1,1))
par(mfrow=c(1,2), oma =c(2,2,2,2))
plot(c(1,1))
plot(c(1,1))
par(mfrow=c(1,2), oma =c(0,0,0,0))
plot(c(1,1))
plot(c(1,1))
devtools::document()
library(pivmet)
devtools::document()
library(pivmet)
devtools::document()
library(pivmet)
devtools::document()
library(pivmet)
devtools::document()
library(pivmet)
devtools::document()
library(pivmet)
devtools::document()
library(pivmet)
devtools::document()
library(pivmet)
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
library(pivmet)
devtools::check()
devtools::document()
library(pivmet)
devtools::check()
devtools::document()
library(pivmet)
devtools::check()
devtools::document()
library(pivmet)
devtools::check()
devtools::document()
library(pivmet)
devtools::check()
devtools::document()
library(pivmet)
devtools::check()
library(pivmet)
devtools::check()
devtools::document()
library(pivmet)
devtools::check()
install.packages("Rd2pdf")
devtools::check()
devtools::check(cleanup = FALSE,manual = TRUE,path = getwd())
devtools::check(manual = TRUE,path = getwd())
devtools::check(cleanup = FALSE,manual = TRUE,path = getwd())
help("check")
devtools::check(pkg ="pivmet", manual = TRUE,path = getwd())
devtools::check(pkg ="pivmet", manual = TRUE)
devtools::check(pkg ='C:\Users\leonardo\Documents\GitHub\pivmet', manual = TRUE)
devtools::check(pkg ="C:\Users\leonardo\Documents\GitHub\pivmet", manual = TRUE)
devtools::check(pkg ="C:/Users/leonardo/Documents/GitHub/pivmet", manual = TRUE)
devtools::check(pkg ="C:/Users/leonardo/Documents/GitHub/pivmet", manual = TRUE)
system("R CMD Rd2pdf MyRpackage")
system("R CMD Rd2pdf pivmet")
setwd("~/GitHub/pivmet")
system("R CMD Rd2pdf pivmet")
system("R CMD Rd2pdf")
system("R CMD Rd2pdf pivmet")
system("R CMD Rd2pdf ")
getwd()
system("R CMD Rd2pdf  "C:/Users/leonardo/Documents/GitHub/pivmet"")
system("R CMD Rd2pdf  C:/Users/leonardo/Documents/GitHub/pivmet")
devtools::document()
install.packages("devtools")
devtools::document()
install.packages("mvtnorm")
devtools::document()
devtools::document()
library(devtools)
install_github("leoegidi/pivmet")
install.packages("bayesmix")
library(bayesmix)
library(bayesmix)
install_github("leoegidi/pivmet")
devtools::document()
library(pivmet)
getwd()
system(R CMD Rd2pdf "C:/Users/leoeg/OneDrive/Documenti/GitHub/pivmet")
system(R CMD Rd2pdf C:/Users/leoeg/OneDrive/Documenti/GitHub/pivmet)
system(R CMD Rd2pdf "C:/Users/leoeg/OneDrive/Documenti/GitHub/pivmet")
system("R CMD Rd2pdf C:/Users/leoeg/OneDrive/Documenti/GitHub/pivmet")
system("R CMD Rd2pdf C:/Users/leoeg/OneDrive/Documenti/GitHub/pivmet")
library(pivmet)
help("MUS")
setwd("~/GitHub/pivmet")
library("pivmet", lib.loc="~/R/win-library/3.5")
remove.packages("pivmet", lib="~/R/win-library/3.5")
remove.packages("pivmet", lib="~/R/win-library/3.5")
setwd("~/GitHub/pivmet")
remove.packages("pivmet", lib="~/R/win-library/3.5")
devtools::document()
install.packages("testthat")
library(testthat)
devtools::document()
library(pivmet)
help(MUS)
library(pivmet)
help("piv_MCMC")
library(pivmet)
devtools::document()
hellp(MUS)
help(MUS)
library(pivmet)
library(pivmet)
devtools::document()
help(MUS)
library(pivmet)
library(pivmet)
devtools::document()
library(pivmet)
help(MUS)
help(bayesplot)
library(bayesplot)
help("mcmc_areas")
help("mcmc_intervals")
library(pivmet)
devtools::document()
help("MUS")
library(pivmet)
devtools::document()
help(MUS)
help(piv_KMeans)
library(RcmdrMisc)
help(KMeans)
devtools::document()
library(pivmet)
help("piv_KMeans")
