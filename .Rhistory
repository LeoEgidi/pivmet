X[n,]=rexp(sample_rep, alpha)
}
sum_X=apply(X,1,sum)
sum_X
n=1000; alpha=2; beta=2; sample_rep=1000
X=matrix(NA, n, sample_rep)
for (h in 1:n){
X[h,]=rexp(sample_rep, alpha)
}
sum_X=apply(X,1,sum)
hist(sum_X, breaks=40)
curve(dgamma(x, alpha, n), add=TRUE)
curve(dgamma(x, n, alpha), col="red", lwd=2, add=TRUE)
hist(sum_X, breaks=40, density=TRUE)
curve(dgamma(x, n, alpha), col="red", lwd=2, add=TRUE)
hist(sum_X, breaks=40, density=TRUE)
help("hist")
hist(sum_X, breaks=40, probability=TRUE)
curve(dgamma(x, n, alpha), col="red", lwd=2, add=TRUE)
curve(dgamma(x, 5/2, 1/2))
curve(dgamma(x, 5/2, 1/2), xlim=c(0,4))
curve(dgamma(x, 5/2, 1/2), xlim=c(0,20))
curve(dchisq(x, 5/2), col="red", add=TRUE)
curve(dchisq(x, 5), col="red", add=TRUE)
integrate(x*dbeta(x,3,3))
help("integrate")
integrate(  x^2 )
expected_function <- function(x){
x*dbeta(x,2,2)
}
integrate(expected_function, 0,1)
expected_function <- function(x,a,b){
x*dbeta(x,a,b)
}
#use integrate function
integrate(expected_function, a=2, b=2, 0,1)
tt<-seq(from=-3, to=3, by=0.01)
length(tt)
set.seed(2)
n=150
edf_beta<-ecdf(rbeta(n, 3,4))
tt<-seq(from=0, to=1, by=0.01)
plot(edf_beta, verticals=TRUE, do.p=FALSE, main="ECDF and CDF")
lines(tt, pbeta(tt,3,4), col=2, lty=2, lwd=2)
help("qqnorm")
y <- rt(200, df = 5)
qqnorm(y); qqline(y, col = 2)
qqplot(y, rt(300, df = 5))
y <- rt(200, df = 5)
qqnorm(y); qqline(y, col = 2)
qqplot(y, rt(300, df = 5))
help("qqnorm")
y <- rt(200, df = 5)
qqnorm(y); qqline(y, col = 2)
y <- rnorm(200, 0,1)
qqnorm(y); qqline(y, col = 2)
y <- rnorm(200, 2,5)
qqnorm(y); qqline(y, col = 2)
set.seed(2)
par(mfrow=c(1,2))
n=50
y=rbeta(n, 3,4)
edf_beta<-ecdf(y)
tt<-seq(from=0, to=1, by=0.01)
plot(edf_beta, verticals=TRUE, do.p=FALSE, main="ECDF and CDF: n=50")
lines(tt, pbeta(tt,3,4), col=2, lty=2, lwd=2)
n2=500
y2=rbeta(n2, 3,4)
edf_beta2<-ecdf(y2)
tt<-seq(from=0, to=1, by=0.01)
plot(edf_beta2, verticals=TRUE, do.p=FALSE, main="ECDF and CDF: n=500")
lines(tt, pbeta(tt,3,4), col=2, lty=2, lwd=2)
qqplot(qbeta(ppoints(n),3,4),y,
main = expression("Q-Q plot for" ~~ {beta}(3,4)))
qqplot(qbeta(ppoints(n),3,4),y,
main = "Q-Q plot for Beta(3,4)"  )))
qqplot(qbeta(ppoints(n),3,4),y,
main = "Q-Q plot for Beta(3,4)"  ))
qqplot(qbeta(ppoints(n),3,4),y,
main = "Q-Q plot for Beta(3,4): n=50")
qqline(y, distribution = function(p) qbeta(p, 3,4),
prob = c(0, 1), col = 2)
install.packages("DAAG")
install.packages("DAAG")
install.packages("DAAG")
install.packages("DAAG")
install.packages("DAAG")
install.packages(DAAG)
install.packages("DAAG")
p=0.5; size1=10; size2=50
#normal approximation
x <- rnorm(size1, size1*p, sqrt(size1*p*(1-p)) )
pnorm(x, size1*p, sqrt(size1*p*(1-p)))
x <- rnorm(size1, size1*p, sqrt(size1*p*(1-p)) )
prob_norm <- pnorm(x, size1*p, sqrt(size1*p*(1-p)))
plot(x, prob_norm, type="h", main="n=10", xlab="x", ylab="f(x)", xlim=c(1,10),
cex.lab=1.5)
size1*p
x <- rnorm(size1, size1*p, sqrt(size1*p*(1-p)) )
prob_norm <- dnorm(x, size1*p, sqrt(size1*p*(1-p)))
plot(x, prob_norm, type="h", main="n=10", xlab="x", ylab="f(x)", xlim=c(1,10),
cex.lab=1.5)
help(dbinom)
x <- rnorm(size1, size1*p, sqrt(size1*p*(1-p)) )
prob_norm <- dnorm(x, size1*p, sqrt(size1*p*(1-p)))
prob_bin <- dbinom(x, size1,p)
plot(x, prob_bin, type="h", main="n=10", xlab="x", ylab="f(x)", xlim=c(1,10),
cex.lab=1.5, col="red")
curve(dnorm(x, size1*p, sqrt(size1*p*(1-p))), add=TRUE)
x <- rnorm(size1, size1*p, sqrt(size1*p*(1-p)) )
prob_norm <- dnorm(x, size1*p, sqrt(size1*p*(1-p)))
prob_bin <- dbinom(x, size1,p)
plot(x, prob_bin, type="h", main="n=10", xlab="x", ylab="f(x)", xlim=c(1,10),
cex.lab=1.5, col="red")
curve(dnorm(x, size1*p, sqrt(size1*p*(1-p))))
curve(dnorm(x, size1*p, sqrt(size1*p*(1-p))), xlim=c(1,10))
lines(prob_bin, type="h", main="n=10", xlab="x", ylab="f(x)", xlim=c(1,10),
cex.lab=1.5, col="red")
plot(prob_bin, type="h", main="n=10", xlab="x", ylab="f(x)", xlim=c(1,10),
cex.lab=1.5, col="red")
prob_bin <- dbinom(x, size1,p)
prob_bin
prob_bin <- dbinom(seq(0:10), size1,p)
prob_bin
x <- rnorm(size1, size1*p, sqrt(size1*p*(1-p)) )
#prob_norm <- dnorm(x, size1*p, sqrt(size1*p*(1-p)))
prob_bin <- dbinom(seq(0:10), size1,p)
curve(dnorm(x, size1*p, sqrt(size1*p*(1-p))), xlim=c(0,10))
lines(prob_bin, type="h", main="n=10", xlab="x", ylab="f(x)", xlim=c(1,10),
cex.lab=1.5, col="red")
x <- rnorm(size1, size1*p, sqrt(size1*p*(1-p)) )
prob_bin <- dbinom(seq(0:10), size1,p)
curve(dnorm(x, size1*p, sqrt(size1*p*(1-p))), xlim=c(0,10), xlab="x", ylab="f(x)")
lines(prob_bin, type="h", main="n=10", xlim=c(1,10),
cex.lab=1.5, col="red")
help(cars)
knitr::knit("Lab12.Rmd", tangle = TRUE, output ="foo.R") )
knitr::knit("Lab12.Rmd", tangle = TRUE, output ="foo.R")
library(knitr)
library(rmarkdown)
knitr::knit("Lab12.Rmd", tangle = TRUE, output ="foo.R")
Musicians <- c( "Selena Gomez",  "Ariana Grande", "Beyonce" , "Taylor Swift",  "Justin Bieber", "Nicki Minaj", "Nicola Gennaro", "Nilson", "Ginevra Carbone")
Others <- c("Cristiano Ronaldo", "Kim Kardashian",  "Kylie Jenner", "Dwayne Johnson", "Neymar", "Lionel Messi",
"Kendall Jenner", "Kourtney Kardashian", "Kevin Hart",)
n1 <- length(Musicians)
n2 <- length(Others)
Musicians <- c( "Selena Gomez",  "Ariana Grande", "Beyonce" , "Taylor Swift",  "Justin Bieber", "Nicki Minaj", "Nicola Gennaro", "Nilson", "Ginevra Carbone")
Others <- c("Cristiano Ronaldo", "Kim Kardashian",  "Kylie Jenner", "Dwayne Johnson", "Neymar", "Lionel Messi",
"Kendall Jenner", "Kourtney Kardashian", "Kevin Hart")
n1 <- length(Musicians)
n2 <- length(Others)
Followers_M<- c(135, 118, 113, 107,  98,  86, 1, 923*10^(-6) )
Followers_O <- c(123, 110, 106, 103,  91,  89,  89,  62,  58)
t <- t.test(Followers_M, Followers_O, mu = 0, alternative ="greater", var.equal =TRUE)
t
n <- 50
K <- 4
M <- 6
y <- matrix(0, M, n )
# generate the values
for (m in 1:M){
y[m, ] <- sample(1:K, n, replace=TRUE, prob = c( 7/16, 5/16, 3/16, 1/16) )
}
observed_matrix <- apply( y,1, table)
chisq.test(observed_matrix, p = c( 7/16, 5/16, 3/16, 1/16) )
n <- 50
K <- 4
M <- 6
y <- matrix(0, M+1, n )
# generate the values
for (m in 1:M){
y[m, ] <- sample(1:K, n, replace=TRUE, prob = c( 7/16, 5/16, 3/16, 1/16) )
}
y[7, ] <- sample(1:K, n, replace=TRUE, prob = c( 2/16, 3/16, 5/16, 6/16) )
observed_matrix <- apply( y,1, table)
chisq.test(observed_matrix, p = c( 7/16, 5/16, 3/16, 1/16) )
set.seed(1)
X <- 1:100
Y <- rnorm(length(X), 2*X + 10, 1)
N <- length(X)
model <- "
model {
for(i in 1 : N){ #data# N
Y[i] ~ dnorm(true.y[i], precision) #data# Y
true.y[i] <- (coef * X[i]) + int #data# X
}
coef ~ dunif(-1000,1000)
int ~ dunif(-1000,1000)
precision ~ dexp(1)
#inits# coef, int, precision
#monitor# coef, int, precision
}"
# A function to return initial values for each chain:
coef <- function(chain) return(switch(chain, "1"= -10, "2"= 10))
int <- function(chain) return(switch(chain, "1"= -10, "2"= 10))
precision <- function(chain) return(switch(chain, "1"= 0.01, "2"= 100))
init1 <- list(  coef=rnorm(1), int=rnorm(1), precision=runif(1))
init2 <- list(  coef=rnorm(1), int=rnorm(1), precision=runif(1))
# Run the simulation:
results <- run.jags(model, inits = list(init1, init2),  n.chains = 2)
library(runjags)
library(rjags)
set.seed(1)
X <- 1:100
Y <- rnorm(length(X), 2*X + 10, 1)
N <- length(X)
model <- "
model {
for(i in 1 : N){ #data# N
Y[i] ~ dnorm(true.y[i], precision) #data# Y
true.y[i] <- (coef * X[i]) + int #data# X
}
coef ~ dunif(-1000,1000)
int ~ dunif(-1000,1000)
precision ~ dexp(1)
#inits# coef, int, precision
#monitor# coef, int, precision
}"
# A function to return initial values for each chain:
coef <- function(chain) return(switch(chain, "1"= -10, "2"= 10))
int <- function(chain) return(switch(chain, "1"= -10, "2"= 10))
precision <- function(chain) return(switch(chain, "1"= 0.01, "2"= 100))
init1 <- list(  coef=rnorm(1), int=rnorm(1), precision=runif(1))
init2 <- list(  coef=rnorm(1), int=rnorm(1), precision=runif(1))
# Run the simulation:
results <- run.jags(model, inits = list(init1, init2),  n.chains = 2)
save(results, file="ris.RData", compress="xz")
log_lik_weibull <- function( data, param){
-sum(dweibull(data, shape = param[1], scale = param[2], log = TRUE))
}
y <- c(155.9, 200.2, 143.8, 150.1,152.1, 142.2, 147, 146, 146, 170.3, 148, 140, 118, 144, 97)
theta <- function(omega) exp(omega)
log_lik_weibull_rep <- function(data, param) log_lik_weibull(data, theta(param))
weib.y.nlm<-suppressWarnings(nlm(log_lik_weibull_rep,c(0,0),hessian=T,data=y))
varOmega<-diag(solve(weib.y.nlm$hessian))
print("Variance for the estimator omega:")
weib.y.nlm
exp(weib.y.nlm$estimate)
help("norm")
dt_ls(x, df, mu, sigma) =
1/sigma * dt((x - mu)/sigma, df)
dpois_ls(x, df, mu, sigma) =
dpois((x - mu))
dpois_ls(x,  mu) =function(x){
dpois((x - mu))}
dpois_ls =function(x, mu){
dpois((x - mu))}
dpois_ls(2,4)
dpois_ls =function(x, mu){
dpois((x - mu))}
245*1.14
280/6
171+144
171/6
library(rstanarm)
help("stan_glmer")
740/16
setwd("~/GitHub/pivmet")
library(devtools)
install_github("pivmet/leoegidi")
install_github("leoegidi/pivmet")
install_github("LeoEgidi/pivmet")
library(effects)
install_github("LeoEgidi/pivmet")
install_github("LeoEgidi/pivmet")
install_github("LeoEgidi/pivmet")
help("install_github")
install_github("r-lib/devtools")
install_github("LeoEgidi/pivmet")
install_github("LeoEgidi/pivmet")
install_github("hadley/pryr")
install_github("LeoEgidi/pivmet")
install_github("LeoEgidi/pivmet")
install_github("LeoEgidi/pivmet", dependencies=TRUE, force =TRUE)
Depends: MASS,
runjags,
rjags,
cluster,
mclust,
rmarkdown,
bayesmix,
Rcmdr,
mvtnorm
install_github("LeoEgidi/pivmet", dependencies=TRUE, force =TRUE)
install.packages("githubinstall")
install.packages("githubinstall")
library(githubinstall)
library("githubinstall")
githubinstall("pivmet")
install_github("LeoEgidi/pivmet", dependencies=TRUE, force =TRUE)
livrary(devtools)
library(devtools)
install.packages("devtools")
library(devtools)
library(devtools)
install_github("leoegidi/pivmet")
devtools::find_rtools(TRUE)
install_github("leoegidi/pivmet")
install_github("leoegidi/pivmet")
install_github("leoegidi/pivmet")
library(MASS)
remove.packages("MASS", lib="C:/Program Files/R/R-3.4.1/library")
remove.packages("MASS", lib="C:/Program Files/R/R-3.4.1/library")
library("cluster", lib.loc="~/R/win-library/3.4")
library("mclust", lib.loc="~/R/win-library/3.4")
remove.packages("cluster", lib="~/R/win-library/3.4")
library("mclust", lib.loc="~/R/win-library/3.4")
remove.packages("mclust", lib="~/R/win-library/3.4")
library("bayesmix", lib.loc="~/R/win-library/3.4")
remove.packages("bayesmix", lib="~/R/win-library/3.4")
library("Rcmdr", lib.loc="~/R/win-library/3.4")
remove.packages("Rcmdr", lib="~/R/win-library/3.4")
remove.packages("mvtnorm", lib="~/R/win-library/3.4")
remove.packages("testthat", lib="~/R/win-library/3.4")
remove.packages("rmarkdown", lib="~/R/win-library/3.4")
remove.packages("runjags", lib="~/R/win-library/3.4")
remove.packages("rjags", lib="~/R/win-library/3.4")
install_github("leoegidi/pivmet")
install_github("leoegidi/pivmet")
install.packages("rjags")
install.packages("rjags")
library(rjags)
install_github("leoegidi/pivmet")
library(devtools)
install_github("leoegidi/pivmet")
install_github("leoegidi/pivmet")
install.packages("mvtnorm")
install.packages("mclust")
install_github("leoegidi/pivmet")
install_github("leoegidi/pivmet")
install_github("leoegidi/pivmet")
install.packages("mclust")
.libPaths()
library(mclust)
install.packages("mclust")
.libPaths()
.libPaths("C:/Users/leonardo/Documents/R/win-library/3.4")
library(devtools)
install_github("leoegidi/pivmet")
library(mclust)
.libPaths()
.libPaths("C:/Users/leonardo/Documents/R/win-library/3.4")
.libPaths()
install.packages("mclust", lib="C:/Users/leonardo/Documents/R/win-library/3.4")
install_github("leoegidi/pivmet")
install_github("leoegidi/pivmet")
install_github("leoegidi/pivmet")
install_github("leoegidi/pivmet")
library(pivmet)
sim_mixture()
data(fish)
y <- fish[,1]
k <- 5
nMC <- 5000
output_bayes <- bayesMCMC(y, k, nMC)
N <- 200
k <- 4
nMC <- 1000
M1 <-c(-.5,8)
M2 <- c(25.5,.1)
M3 <- c(49.5,8)
M4 <- c(63.0,.1)
Mu <- matrix(rbind(M1,M2,M3,M4),c(4,2))
stdev=cbind(rep(1,k), rep(200,k))
Sigma.p1 <- matrix(c(1,0,0,1), nrow=2, ncol=2)
Sigma.p2 <- matrix(c(200,0,0,200), nrow=2, ncol=2)
W <- c(0.2,0.8)
sim <- sim_mixture(N,k,Mu, stdev, Sigma.p1,Sigma.p2,W)
output_bayes <- bayesMCMC(sim$y, k, nMC)
remove.packages("pivmet", lib="~/R/win-library/3.4")
install_github("leoegidi/pivmet")
remove.packages("pivmet", lib="~/R/win-library/3.4")
install_github("leoegidi/pivmet")
install_github("leoegidi/pivmet")
library(devtools)
install_github("leoegidi/pivmet")
install_github("leoegidi/pivmet")
install_github("leoegidi/pivmet")
library(bayesmix)
remove.packages("bayesmix", lib="~/R/win-library/3.4")
install_github("leoegidi/pivmet")
library(rjags)
install.packages(rjags)
install.packages("rjags")
install_github("leoegidi/pivmet")
library(rjags)
sessionInfo()
remove.packages("rjags", lib="~/R/win-library/3.4")
install.packages("rjags", dependencies = TRUE)
install.packages("rjags", dependencies = TRUE)
library(devtools)
library(rjags)
install_github("leoegidi/pivmet")
install_github("leoegidi/pivmet")
install.packages("bayesmix", dependencies=TRUE)
library(bayesmix)
install_github("leoegidi/pivmet")
install.packages("mvtnorm", dependencies=TRUE)
library(mvtnorm)
install_github("leoegidi/pivmet")
library("pivmet", lib.loc="~/R/win-library/3.4")
remove.packages("pivmet", lib="~/R/win-library/3.4")
library("pivmet", lib.loc="~/R/win-library/3.4")
remove.packages("pivmet", lib="~/R/win-library/3.4")
library(pivmet)
N <- 200
k <- 3
nMC <- 5000
M1  <- c(-.5,8)
M2  <- c(25.5,.1)
M3  <- c(49.5,8)
Mu  <- matrix(rbind(M1,M2,M3),c(k,2))
stdev <- cbind(rep(1,k), rep(200,k))
Sigma.p1 <- matrix(c(stdev[1,1],0,0,stdev[1,1]),
nrow=2, ncol=2)
Sigma.p2 <- matrix(c(stdev[1,2],0,0,stdev[1,2]),
nrow=2, ncol=2)
W <- c(0.2,0.8)
sim <- sim_mixture(N,k,Mu,stdev,Sigma.p1,Sigma.p2,W)
output_bayes <- bayesMCMC(sim$y, k, nMC)
relab_est <-
pivotal_relabelling(mu_switch=output_bayes$mu_switch,
group=output_bayes$groupPost,
clustering=output_bayes$clust_sel,
Mu=output_bayes$Mu,
nMC = nMC)
plot_pivotal(y= sim$y,
est = relab_est$mu_rel_median,
chains=relab_est$mu_rel_complete,
type="chains",
mu_switch=output_bayes$mu_switch,
n.iter=relab_est$Final_it,
true.means= output_bayes$Mu)
N <- 200
k <- 3
nMC <- 5000
M1  <- c(-.5,8)
M2  <- c(25.5,.1)
M3  <- c(49.5,8)
Mu  <- matrix(rbind(M1,M2,M3),c(k,2))
stdev <- cbind(rep(1,k), rep(200,k))
Sigma.p1 <- matrix(c(stdev[1,1],0,0,stdev[1,1]),
nrow=2, ncol=2)
Sigma.p2 <- matrix(c(stdev[1,2],0,0,stdev[1,2]),
nrow=2, ncol=2)
W <- c(0.2,0.8)
sim <- sim_mixture(N,k,Mu,stdev,Sigma.p1,Sigma.p2,W)
output_bayes <- bayesMCMC(sim$y, k, nMC)
relab_est <-
pivotal_relabelling(mu_switch=output_bayes$mu_switch,
group=output_bayes$groupPost,
clustering=output_bayes$clust_sel,
Mu=output_bayes$Mu,
nMC = nMC)
plot_pivotal(y= sim$y,
est = relab_est$mu_rel_median,
chains=relab_est$mu_rel_complete,
type="chains",
mu_switch=output_bayes$mu_switch,
n.iter=relab_est$Final_it,
true.means= output_bayes$Mu)
N <- 200
k <- 3
nMC <- 5000
M1  <- c(-.5,8)
M2  <- c(25.5,.1)
M3  <- c(49.5,8)
Mu  <- matrix(rbind(M1,M2,M3),c(k,2))
stdev <- cbind(rep(1,k), rep(200,k))
Sigma.p1 <- matrix(c(stdev[1,1],0,0,stdev[1,1]),
nrow=2, ncol=2)
Sigma.p2 <- matrix(c(stdev[1,2],0,0,stdev[1,2]),
nrow=2, ncol=2)
W <- c(0.2,0.8)
sim <- sim_mixture(N,k,Mu,stdev,Sigma.p1,Sigma.p2,W)
output_bayes <- bayesMCMC(sim$y, k, nMC)
relab_est <-
pivotal_relabelling(mu_switch=output_bayes$mu_switch,
group=output_bayes$groupPost,
clustering=output_bayes$clust_sel,
Mu=output_bayes$Mu,
nMC = nMC)
plot_pivotal(y= sim$y,
est = relab_est$mu_rel_median,
chains=relab_est$mu_rel_complete,
type="chains",
mu_switch=output_bayes$mu_switch,
n.iter=relab_est$Final_it,
true.means= output_bayes$Mu)
N <- 200
k <- 3
nMC <- 5000
M1  <- c(-.5,8)
M2  <- c(25.5,.1)
M3  <- c(49.5,8)
Mu  <- matrix(rbind(M1,M2,M3),c(k,2))
stdev <- cbind(rep(1,k), rep(200,k))
Sigma.p1 <- matrix(c(stdev[1,1],0,0,stdev[1,1]),
nrow=2, ncol=2)
Sigma.p2 <- matrix(c(stdev[1,2],0,0,stdev[1,2]),
nrow=2, ncol=2)
W <- c(0.2,0.8)
sim <- sim_mixture(N,k,Mu,stdev,Sigma.p1,Sigma.p2,W)
output_bayes <- bayesMCMC(sim$y, k, nMC)
help(Rmcdr::KMeans())
help(Rmcdr::KMeans)
Rmcdr::KMeans(rnorm(10),3)
Rcmdr::KMeans(rnorm(10),3)
library(pivmet)
help("pivotal_relabelling")
library(pivmet)
library(pivmet)
