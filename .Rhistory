ind.gi
ind.gi1 <- rbind(ind.gi1,c(j,
sum(C[j,com.gi],na.rm=TRUE),           #maxsumint
sum(C[j,com.ngi]),                     #minsumnoint
sum(C[j,com.gi],na.rm=TRUE)-sum(C[j,com.ngi])))
ind.gi1
g.i=1
# choose the pivots within each group
for (j in com.gi){
ind.gi  <- rbind(ind.gi,c(j,sort(C[j,com.gi],
decreasing=TRUE)))
ind.gi1 <- rbind(ind.gi1,c(j,
sum(C[j,com.gi],na.rm=TRUE),           #maxsumint
sum(C[j,com.ngi]),                     #minsumnoint
sum(C[j,com.gi],na.rm=TRUE)-sum(C[j,com.ngi])))
}                                            #maxsumdiff
ind.gi1
com.gi
com.gi[which.max(ind.gi1[,2])]
com.gi[which.min(ind.gi1[,3])]
com.gi[which.max(ind.gi1[,4])]
com.gi
ind.gi1
N <- dim(C)[1]
k <- length(unique(clusters))
Cg1 <- rep(NA, k)
Cg  <- matrix(NA, ncol=3, nrow=k)
for (g.i in 1:k){
com.gi  <-  (1:N)[clusters==g.i]
com.ngi <-  (1:N)[clusters!=g.i]
ind.gi  <- c()
ind.gi1 <- c()
# choose the pivots within each group
for (j in com.gi){
ind.gi  <- rbind(ind.gi,c(j,sort(C[j,com.gi],
decreasing=TRUE)))
ind.gi1 <- rbind(ind.gi1,c(j,
sum(C[j,com.gi],na.rm=TRUE),           #maxsumint
sum(C[j,com.ngi]),                     #minsumnoint
sum(C[j,com.gi],na.rm=TRUE)-sum(C[j,com.ngi])))
}                                            #maxsumdiff
# Methods: from 1 to 4
if (!is.null(ind.gi))
Cg[g.i, 1] <- com.gi[which.max(ind.gi1[,2])]
if (!is.null(ind.gi))
Cg[g.i, 2] <- com.gi[which.min(ind.gi1[,3])]
if (!is.null(ind.gi))
Cg[g.i, 3] <- com.gi[which.max(ind.gi1[,4])]
if (!is.null(ind.gi)){
Cg1[g.i] <- ind.gi[do.call(order,
as.data.frame(-ind.gi[,-1]))[1],1]
}
}
# For each method, we store the selected pivotal units
Cg <- Cg[,1:3]
Cg
C <- matrix(NA, N,N)
for (i in 1:(N-1)){
for (j in (i+1):N){
C[i,j] <- sum(a[,i]==a[,j])/H
C[j,i] <- C[i,j]
}}
km <- kmeans(x, centers =3)
# Apply three pivotal criteria to the co-association matrix
ris <- piv_sel(C, clusters = km$cluster)
ind.gi1
data(iris)
# select the columns of variables
x<- iris[,1:4]
N <- nrow(x)
H <- 1000
a <- matrix(NA, H, N)
# Perform H k-means partitions
for (h in 1:H){
a[h,] <- kmeans(x, centers = 3)$cluster
}
# Build the co-association matrix
C <- matrix(1, N,N)
for (i in 1:(N-1)){
for (j in (i+1):N){
C[i,j] <- sum(a[,i]==a[,j])/H
C[j,i] <- C[i,j]
}}
km <- kmeans(x, centers =3)
# Apply three pivotal criteria to the co-association matrix
ris <- piv_sel(C, clusters = km$cluster)
clusters = km$cluster
N <- dim(C)[1]
k <- length(unique(clusters))
Cg1 <- rep(NA, k)
Cg  <- matrix(NA, ncol=3, nrow=k)
g.i=1
com.gi  <-  (1:N)[clusters==g.i]
com.ngi <-  (1:N)[clusters!=g.i]
ind.gi  <- c()
ind.gi1 <- c()
# choose the pivots within each group
for (j in com.gi){
ind.gi  <- rbind(ind.gi,c(j,sort(C[j,com.gi],
decreasing=TRUE)))
ind.gi1 <- rbind(ind.gi1,c(j,
sum(C[j,com.gi],na.rm=TRUE),           #maxsumint
sum(C[j,com.ngi]),                     #minsumnoint
sum(C[j,com.gi],na.rm=TRUE)-sum(C[j,com.ngi])))
}                                            #maxsumdiff
ind.gi1
if (!is.null(ind.gi))
Cg[g.i, 1] <- com.gi[which.max(ind.gi1[,2])]
if (!is.null(ind.gi))
Cg[g.i, 2] <- com.gi[which.min(ind.gi1[,3])]
if (!is.null(ind.gi))
Cg[g.i, 3] <- com.gi[which.max(ind.gi1[,4])]
if (!is.null(ind.gi)){
Cg1[g.i] <- ind.gi[do.call(order,
as.data.frame(-ind.gi[,-1]))[1],1]
}
# For each method, we store the selected pivotal units
Cg <- Cg[,1:3]
Cg
g.i=2
com.gi  <-  (1:N)[clusters==g.i]
com.ngi <-  (1:N)[clusters!=g.i]
ind.gi  <- c()
ind.gi1 <- c()
# choose the pivots within each group
for (j in com.gi){
ind.gi  <- rbind(ind.gi,c(j,sort(C[j,com.gi],
decreasing=TRUE)))
ind.gi1 <- rbind(ind.gi1,c(j,
sum(C[j,com.gi],na.rm=TRUE),           #maxsumint
sum(C[j,com.ngi]),                     #minsumnoint
sum(C[j,com.gi],na.rm=TRUE)-sum(C[j,com.ngi])))
}                                            #maxsumdiff
if (!is.null(ind.gi))
Cg[g.i, 1] <- com.gi[which.max(ind.gi1[,2])]
if (!is.null(ind.gi))
Cg[g.i, 2] <- com.gi[which.min(ind.gi1[,3])]
if (!is.null(ind.gi))
Cg[g.i, 3] <- com.gi[which.max(ind.gi1[,4])]
if (!is.null(ind.gi)){
Cg1[g.i] <- ind.gi[do.call(order,
as.data.frame(-ind.gi[,-1]))[1],1]
}
# For each method, we store the selected pivotal units
Cg <- Cg[,1:3]
ind.gi1
Cg
N <- dim(C)[1]
k <- length(unique(clusters))
Cg1 <- rep(NA, k)
Cg  <- matrix(NA, ncol=3, nrow=k)
for (g.i in 1:k){
com.gi  <-  (1:N)[clusters==g.i]
com.ngi <-  (1:N)[clusters!=g.i]
ind.gi  <- c()
ind.gi1 <- c()
# choose the pivots within each group
for (j in com.gi){
ind.gi  <- rbind(ind.gi,c(j,sort(C[j,com.gi],
decreasing=TRUE)))
ind.gi1 <- rbind(ind.gi1,c(j,
sum(C[j,com.gi],na.rm=TRUE),           #maxsumint
sum(C[j,com.ngi]),                     #minsumnoint
sum(C[j,com.gi],na.rm=TRUE)-sum(C[j,com.ngi])))
}                                            #maxsumdiff
# Methods: from 1 to 4
if (!is.null(ind.gi))
Cg[g.i, 1] <- com.gi[which.max(ind.gi1[,2])]
if (!is.null(ind.gi))
Cg[g.i, 2] <- com.gi[which.min(ind.gi1[,3])]
if (!is.null(ind.gi))
Cg[g.i, 3] <- com.gi[which.max(ind.gi1[,4])]
if (!is.null(ind.gi)){
Cg1[g.i] <- ind.gi[do.call(order,
as.data.frame(-ind.gi[,-1]))[1],1]
}
}
# For each method, we store the selected pivotal units
Cg <- Cg[,1:3]
Cg
C <- matrix(NA, N,N)
for (i in 1:(N-1)){
for (j in (i+1):N){
C[i,j] <- sum(a[,i]==a[,j])/H
C[j,i] <- C[i,j]
}}
km <- kmeans(x, centers =3)
# Apply three pivotal criteria to the co-association matrix
ris <- piv_sel(C, clusters = km$cluster)
clusters <- km$cluster
N <- dim(C)[1]
k <- length(unique(clusters))
Cg1 <- rep(NA, k)
Cg  <- matrix(NA, ncol=3, nrow=k)
for (g.i in 1:k){
com.gi  <-  (1:N)[clusters==g.i]
com.ngi <-  (1:N)[clusters!=g.i]
ind.gi  <- c()
ind.gi1 <- c()
# choose the pivots within each group
for (j in com.gi){
ind.gi  <- rbind(ind.gi,c(j,sort(C[j,com.gi],
decreasing=TRUE)))
ind.gi1 <- rbind(ind.gi1,c(j,
sum(C[j,com.gi],na.rm=TRUE),           #maxsumint
sum(C[j,com.ngi]),                     #minsumnoint
sum(C[j,com.gi],na.rm=TRUE)-sum(C[j,com.ngi])))
}                                            #maxsumdiff
# Methods: from 1 to 4
if (!is.null(ind.gi))
Cg[g.i, 1] <- com.gi[which.max(ind.gi1[,2])]
if (!is.null(ind.gi))
Cg[g.i, 2] <- com.gi[which.min(ind.gi1[,3])]
if (!is.null(ind.gi))
Cg[g.i, 3] <- com.gi[which.max(ind.gi1[,4])]
if (!is.null(ind.gi)){
Cg1[g.i] <- ind.gi[do.call(order,
as.data.frame(-ind.gi[,-1]))[1],1]
}
}
# For each method, we store the selected pivotal units
Cg <- Cg[,1:3]
Cg
C <- matrix(NA, N,N)
for (i in 1:(N-1)){
for (j in (i+1):N){
C[i,j] <- sum(a[,i]==a[,j])/H
C[j,i] <- C[i,j]
}}
C[1:4,1:4]
devtools::document()
library(pivmet)
N   <- 200
k   <- 4
D   <- 2
nMC <- 1000
M1  <- c(-.5,8)
M2  <- c(25.5,.1)
M3  <- c(49.5,8)
M4  <- c(63.0,.1)
Mu  <- rbind(M1,M2,M3,M4)
Sigma.p1 <- diag(D)
Sigma.p2 <- 20*diag(D)
W <- c(0.2,0.8)
sim <- piv_sim(N = N, k = k, Mu = Mu,
Sigma.p1 = Sigma.p1,
Sigma.p2 = Sigma.p2, W = W)
## rjags (default)
res <- piv_MCMC(y = sim$y, k =k, nMC = nMC)
res$pivots
res$C
res$pivots
res$C[1:4,1:4]
N
k
clusters <-as.vector(res$grr)
clusters
res$grr
Cg1 <- rep(NA, k)
Cg  <- matrix(NA, ncol=3, nrow=k)
g.i=1
res$pivots
com.gi  <-  (1:N)[clusters==g.i]
com.ngi <-  (1:N)[clusters!=g.i]
ind.gi  <- c()
ind.gi1 <- c()
# choose the pivots within each group
for (j in com.gi){
ind.gi  <- rbind(ind.gi,c(j,sort(C[j,com.gi],
decreasing=TRUE)))
ind.gi1 <- rbind(ind.gi1,c(j,
sum(C[j,com.gi],na.rm=TRUE),           #maxsumint
sum(C[j,com.ngi]),                     #minsumnoint
sum(C[j,com.gi],na.rm=TRUE)-sum(C[j,com.ngi])))
}                                            #maxsumdiff
C <- res$C
Cg1 <- rep(NA, k)
Cg  <- matrix(NA, ncol=3, nrow=k)
g.i=1
com.gi  <-  (1:N)[clusters==g.i]
com.ngi <-  (1:N)[clusters!=g.i]
ind.gi  <- c()
ind.gi1 <- c()
# choose the pivots within each group
for (j in com.gi){
ind.gi  <- rbind(ind.gi,c(j,sort(C[j,com.gi],
decreasing=TRUE)))
ind.gi1 <- rbind(ind.gi1,c(j,
sum(C[j,com.gi],na.rm=TRUE),           #maxsumint
sum(C[j,com.ngi]),                     #minsumnoint
sum(C[j,com.gi],na.rm=TRUE)-sum(C[j,com.ngi])))
}                                            #maxsumdiff
ind.gi1
com.gi
sum(C[1,1])-sum(C[1,com.ngi]))
sum(C[1,1])-sum(C[1,com.ngi])
sum(C[1,1], na.rm=TRUE)-sum(C[1,com.ngi])
sum(C[1,com.gi],na.rm=TRUE)-sum(C[1,com.ngi])
which.max(ind.gi1[,4])
com.gi[which.max(ind.gi1[,4])]
g.i=2
com.gi  <-  (1:N)[clusters==g.i]
com.ngi <-  (1:N)[clusters!=g.i]
ind.gi  <- c()
ind.gi1 <- c()
# choose the pivots within each group
for (j in com.gi){
ind.gi  <- rbind(ind.gi,c(j,sort(C[j,com.gi],
decreasing=TRUE)))
ind.gi1 <- rbind(ind.gi1,c(j,
sum(C[j,com.gi],na.rm=TRUE),           #maxsumint
sum(C[j,com.ngi]),                     #minsumnoint
sum(C[j,com.gi],na.rm=TRUE)-sum(C[j,com.ngi])))
}                                            #maxsumdiff
ind.gi1
g.i=4
com.gi  <-  (1:N)[clusters==g.i]
com.ngi <-  (1:N)[clusters!=g.i]
ind.gi  <- c()
ind.gi1 <- c()
# choose the pivots within each group
for (j in com.gi){
ind.gi  <- rbind(ind.gi,c(j,sort(C[j,com.gi],
decreasing=TRUE)))
ind.gi1 <- rbind(ind.gi1,c(j,
sum(C[j,com.gi],na.rm=TRUE),           #maxsumint
sum(C[j,com.ngi]),                     #minsumnoint
sum(C[j,com.gi],na.rm=TRUE)-sum(C[j,com.ngi])))
}                                            #maxsumdiff
ind.gi1
res$pivots
plot(sim$yy)
plot(sim$y)
points(sim$y[res$pivots,1], sim$y[res$pivots,2], col="red", pch=5)
res$pivots
C
C[1:2,1:2]
diag(C) <- 1
C[1:2,1:2]
Cg1 <- rep(NA, k)
Cg  <- matrix(NA, ncol=3, nrow=k)
for (g.i in 1:k){
com.gi  <-  (1:N)[clusters==g.i]
com.ngi <-  (1:N)[clusters!=g.i]
ind.gi  <- c()
ind.gi1 <- c()
# choose the pivots within each group
for (j in com.gi){
ind.gi  <- rbind(ind.gi,c(j,sort(C[j,com.gi],
decreasing=TRUE)))
ind.gi1 <- rbind(ind.gi1,c(j,
sum(C[j,com.gi],na.rm=TRUE),           #maxsumint
sum(C[j,com.ngi]),                     #minsumnoint
sum(C[j,com.gi],na.rm=TRUE)-sum(C[j,com.ngi])))
}                                            #maxsumdiff
# Methods: from 1 to 4
if (!is.null(ind.gi))
Cg[g.i, 1] <- com.gi[which.max(ind.gi1[,2])]
if (!is.null(ind.gi))
Cg[g.i, 2] <- com.gi[which.min(ind.gi1[,3])]
if (!is.null(ind.gi))
Cg[g.i, 3] <- com.gi[which.max(ind.gi1[,4])]
if (!is.null(ind.gi)){
Cg1[g.i] <- ind.gi[do.call(order,
as.data.frame(-ind.gi[,-1]))[1],1]
}
}
# For each method, we store the selected pivotal units
Cg <- Cg[,1:3]
Cg
N  <- 620
k  <- 3
n1 <- 20
n2 <- 100
n3 <- 500
x  <- matrix(NA, N,2)
truegroup <- c( rep(1,n1), rep(2, n2), rep(3, n3))
x[1:n1,] <- rmvnorm(n1, c(1,5), sigma=diag(2))
x[(n1+1):(n1+n2),] <- rmvnorm(n2, c(4,0), sigma=diag(2))
x[(n1+n2+1):(n1+n2+n3),] <- rmvnorm(n3, c(6,6), sigma=diag(2))
# Apply piv_KMeans with MUS as pivotal criterion
res <- piv_KMeans(x, k)
library(mvtnorm)
N  <- 620
k  <- 3
n1 <- 20
n2 <- 100
n3 <- 500
x  <- matrix(NA, N,2)
truegroup <- c( rep(1,n1), rep(2, n2), rep(3, n3))
x[1:n1,] <- rmvnorm(n1, c(1,5), sigma=diag(2))
x[(n1+1):(n1+n2),] <- rmvnorm(n2, c(4,0), sigma=diag(2))
x[(n1+n2+1):(n1+n2+n3),] <- rmvnorm(n3, c(6,6), sigma=diag(2))
# Apply piv_KMeans with MUS as pivotal criterion
res <- piv_KMeans(x, k)
res$coass
res$coass[1:2, 1:2]
res2 <- piv_KMeans(x, k, piv.criterion ="maxsumdiff")
plot(x)
points(x[res$pivots,1], x[res$pivots,2], col="red", pch=5)
points(x[res$pivots,1], x[res$pivots,2], col="red", pch=5, bg="red")
points(x[res$pivots,1], x[res$pivots,2], col="red", pch=15, bg="red")
points(x[res2$pivots,1], x[res2$pivots,2], col="green", pch=15, bg="red")
N <- 620
centers  <- 3
n1 <- 20
n2 <- 100
n3 <- 500
x  <- matrix(NA, N,2)
truegroup <- c( rep(1,n1), rep(2, n2), rep(3, n3))
x[1:n1,]=rmvnorm(n1, c(1,5), sigma=diag(2))
x[(n1+1):(n1+n2),]=rmvnorm(n2, c(4,0), sigma=diag(2))
x[(n1+n2+1):(n1+n2+n3),]=rmvnorm(n3, c(6,6), sigma=diag(2))
# Build a similarity matrix from clustering ensembles
H <- 1000
a <- matrix(NA, H, N)
for (h in 1:H){
a[h,] <- kmeans(x,centers)$cluster
}
sim_matr <- matrix(NA, N,N)
for (i in 1:(N-1)){
for (j in (i+1):N){
sim_matr[i,j] <- sum(a[,i]==a[,j])/H
sim_matr[j,i] <- sim_matr[i,j]
}
}
# Obtain a clustering solution via kmeans with multiple random seeds
cl <- KMeans(x, centers)$cluster
# Find three pivots
mus_alg <- MUS(C = sim_matr, clusters = cl)
library(RcmdrMisc)
N <- 620
centers  <- 3
n1 <- 20
n2 <- 100
n3 <- 500
x  <- matrix(NA, N,2)
truegroup <- c( rep(1,n1), rep(2, n2), rep(3, n3))
x[1:n1,]=rmvnorm(n1, c(1,5), sigma=diag(2))
x[(n1+1):(n1+n2),]=rmvnorm(n2, c(4,0), sigma=diag(2))
x[(n1+n2+1):(n1+n2+n3),]=rmvnorm(n3, c(6,6), sigma=diag(2))
# Build a similarity matrix from clustering ensembles
H <- 1000
a <- matrix(NA, H, N)
for (h in 1:H){
a[h,] <- kmeans(x,centers)$cluster
}
sim_matr <- matrix(NA, N,N)
for (i in 1:(N-1)){
for (j in (i+1):N){
sim_matr[i,j] <- sum(a[,i]==a[,j])/H
sim_matr[j,i] <- sim_matr[i,j]
}
}
# Obtain a clustering solution via kmeans with multiple random seeds
cl <- KMeans(x, centers)$cluster
# Find three pivots
mus_alg <- MUS(C = sim_matr, clusters = cl)
devtools::document()
library(pivmet)
library(pivmet)
data(iris)
# select the columns of variables
x<- iris[,1:4]
N <- nrow(x)
H <- 1000
a <- matrix(NA, H, N)
# Perform H k-means partitions
for (h in 1:H){
a[h,] <- kmeans(x, centers = 3)$cluster
}
# Build the co-association matrix
C <- matrix(1, N,N)
for (i in 1:(N-1)){
for (j in (i+1):N){
C[i,j] <- sum(a[,i]==a[,j])/H
C[j,i] <- C[i,j]
}}
km <- kmeans(x, centers =3)
# Apply three pivotal criteria to the co-association matrix
ris <- piv_sel(C, clusters = km$cluster)
ris$pivots
help("KMeans")
data(USArrests)
KMeans(USArrests, centers=3, iter.max=10)
data(USArrests)
a<-KMeans(USArrests, centers=3, iter.max=10)
b<-kmeans(USArrests, centers=3, iter.max=10, nstart=10)
a$tot.withinss
b$tot.withinss
a$centers
b$centers
b<-kmeans(USArrests, centers=3, iter.max=10, nstart=1)
b$centers
devtools
devtools::check()
devtools::submit()
devtools::submit()
devtools::submit_cran()
devtools::check()
devtools::check()
sessionInfo()
install.packages(c("cluster", "mclust", "MASS",
"corpcor", "runjags", "rstan", "bayesmix",
"rjags", "mvtnorm", "bayesplot"))
install.packages("roxygen2")
install.packages("rmarkdown")
devtools::check()
devtools::check()
install.packages("devtools")
devtools::check()
devtools::submit_cran()
