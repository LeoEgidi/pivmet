numeffettivogruppi <- apply(group,1,FUN = function(x) length(unique(x)))
sm <- sims_biv$mu[numeffettivogruppi==k,,]
true.iter <- dim(sm)[1]
if (sum(numeffettivogruppi==k)==0){
return(print("HMC has not never been able to identify the required number of groups and the process has been interrupted"))
#return(1)
}else{
mu_pre_switch <- array(rep(0, true.iter*D*k), dim=c(true.iter,D,k))
for (i in 1:true.iter)
mu_pre_switch[i,,] <- t(sm[i,,])
}
mcmc_mean_raw = mu_pre_switch_compl
mcmc_weight_raw = prob.st
mcmc_sd_raw = tau
group <- sims_biv$z[numeffettivogruppi==k,]
mu <- mu_pre_switch
tau <- sims_biv$L_sigma[numeffettivogruppi==k, ]
prob.st <- sims_biv$theta[numeffettivogruppi==k,]
FreqGruppiJags <- table(group)
model_code <- mix_biv
}
group.orig <- group
verigruppi <- as.double(names(table(group)))
prob.st <- prob.st[,verigruppi]
mu <- mu[,,verigruppi]
#tau <- tau[,verigruppi]
# Switching Post
cont <- 0
for (l in verigruppi){
cont <- cont+1
group.orig[group==l] <- cont
}
k.orig <- k
if (cont > 1){
k <- cont
}
mu_switch  <- array(rep(0, true.iter*D*k), dim=c(true.iter,D,k))
prob.st_switch <-  array(0, dim=c(true.iter,k))
group <- group*0
z <- array(0,dim=c(N, k, true.iter))
for (i in 1:true.iter){
perm <- sample(1:k,k,replace=FALSE)
for (j in 1:k){
#post-processing
group[i,group.orig[i,]==j] <- perm[j]
}
mu_switch[i,,] <- mu[i,,perm]
prob.st_switch[i,] <- prob.st[i,perm]
}
for (i in 1:true.iter){
for (j in 1:N){
z[j,group[i,j],i] <- 1
}
}
mcmc_mean <- mu_switch
mcmc_sd <- tau
mcmc_weight <- prob.st_switch
}
FreqGruppiJagsPERM <- table(group)
Freq <- cbind(FreqGruppiJags,FreqGruppiJagsPERM)
colnames(Freq) <- c("JAGS raw groups", "JAGS post-processed groups")
# Similarity matrix based on MCMC sampling------------------------
nz <- dim(z)[1]
M <- dim(z)[3]
C <- matrix(1,nz,nz)
zm <- apply(z,c(1,3),FUN=function(x) sum(x*(1:length(x))))
for (i in 1:(nz-1)){
for (j in (i+1):nz){
C[i,j] <- sum(zm[i,]==zm[j,])/M
C[j,i] <- C[i,j]
}
}
matdissim <- 1-C
diag(matdissim) <- 0
# Clustering on dissimilarity matrix-------------
if (missing(clustering)){
#clustering <- "diana"
gr  <- diana(matdissim,diss=TRUE)
grr <- cutree(gr, k)
}else if(clustering =="diana"){
gr  <- diana(matdissim,diss=TRUE)
grr <- cutree(gr, k)
}else if(clustering == "hclust"){
gr  <- hclust(as.dist(matdissim))
grr <- cutree(gr, k)
}
available_met <- 3
piv.criterion.choices <- c("maxsumint", "minsumnoint",
"maxsumdiff")
if (missing(piv.criterion)){
piv.criterion <- "maxsumdiff"
}
if (piv.criterion=="maxsumint"||
piv.criterion=="minsumnoint"||
piv.criterion=="maxsumdiff" ){
piv.index <- (1:3)[piv.criterion.choices==piv.criterion]
piv.index.pivotal <- c(1,2,3)
available_met <- 3
x <- c(1:available_met)
clust  <-  piv_sel(C=C, clusters=as.vector(grr))
pivots <- clust$pivots[,piv.index.pivotal[piv.index]]
}else if(piv.criterion=="MUS"){
if (k <=4 & sum(C==0)!=0){
mus_res    <- MUS(C, grr)
clust  <-  mus_res$pivots
}else{
print("maxsumdiff criterion instead of MUS has been adopted due to
computational efficiency")
clust  <-  piv_sel(C=C,  clusters=as.vector(grr))
pivots <- clust$pivots[,3]
}
}
return(list( true.iter = true.iter,
#z=z,
Mu = mu_inits,
#ris=ris,
groupPost=group,
mcmc_mean = mcmc_mean,
mcmc_sd = mcmc_sd,
mcmc_weight = mcmc_weight,
mcmc_mean_raw = mcmc_mean_raw,
mcmc_sd_raw = mcmc_sd_raw,
mcmc_weight_raw = mcmc_weight_raw,
C=C,
grr=grr,
pivots = pivots,
#print = printed,
model = model_code))
}
piv_MCMC(y=sim$y, k=3, nMC=300)
library(pivmet)
N  <- 2000
k  <- 3
D <- 2
M1 <- c(-45,8,3)
M2 <- c(45,.1, 3)
M3 <- c(100,8, 5)
Mu <- matrix(rbind(M1,M2,M3),c(k,D))
sds <- cbind(rep(1,k), rep(20,k))
Sigma.p1 <- matrix(c( sds[1,1]^2, 0,0,
sds[1,1]^2), nrow=D, ncol=D)
Sigma.p2 <- matrix(c(sds[1,2]^2, 0,0,
sds[1,2]^2), nrow=D, ncol=D)
W   <- c(0.2,0.8)
sim <- piv_sim(N = N, k = k, Mu = Mu, Sigma.p1 = Sigma.p1,
Sigma.p2 = Sigma.p2, W = W)
devtools::document()
help(piv_sim)
N  <- 2000
k  <- 3
D <- 2
M1 <- c(-45,8)
M2 <- c(45,.1)
M3 <- c(100,8)
Mu <- rbind(M1,M2,M3)
Sigma.p1 <- diag(D)
Sigma.p2 <- 20*diag(D)
W   <- c(0.2,0.8)
sim <- piv_sim(N = N, k = k, Mu = Mu, Sigma.p1 = Sigma.p1,
Sigma.p2 = Sigma.p2, W = W)
piv_MCMC(sim$y, 3, 300)
sim$y
N  <- 2000
k  <- 3
D <- 3
M1 <- c(-45,8,2)
M2 <- c(45,.1,3)
M3 <- c(100,8,4)
Mu <- rbind(M1,M2,M3)
Sigma.p1 <- diag(D)
Sigma.p2 <- 20*diag(D)
W   <- c(0.2,0.8)
sim <- piv_sim(N = N, k = k, Mu = Mu, Sigma.p1 = Sigma.p1,
Sigma.p2 = Sigma.p2, W = W)
library(pivmet)
N  <- 2000
k  <- 3
D <- 3
M1 <- c(-45,8,2)
M2 <- c(45,.1,3)
M3 <- c(100,8,4)
Mu <- rbind(M1,M2,M3)
Sigma.p1 <- diag(D)
Sigma.p2 <- 20*diag(D)
W   <- c(0.2,0.8)
sim <- piv_sim(N = N, k = k, Mu = Mu, Sigma.p1 = Sigma.p1,
Sigma.p2 = Sigma.p2, W = W)
piv_MCMC(sim$y, 3, 390)
y<-sim$y
k<-3
nMC <- 390
N <- dim(y)[1]
D <- dim(y)[2]
# Parameters' initialization
clust_inits <- KMeans(y, k)$cluster
#cutree(hclust(dist(y), "average"),k)
mu_inits <- matrix(0,k,D)
library(RmcdrMisc)
library(RcmdrMisc)
#cutree(hclust(dist(y), "average"),k)
mu_inits <- matrix(0,k,D)
for (j in 1:k){
for (d in 1:D){
mu_inits[j, d] <- mean(y[clust_inits==j,d])
}}
#Reorder mu_inits according to the x-coordinate
mu_inits <-
mu_inits[sort(mu_inits[,1], decreasing=FALSE, index.return=TRUE)$ix,]
mu_0 <- rep(0, D)
S2 <- diag(D)/100000
S3 <- diag(D)/100000
alpha <- rep(1,k)
# Data
dati.biv <- list(y = y, N = N, k = k, D = D,
S2= S2, S3= S3, mu_0=mu_0,
alpha = alpha)
# Model
mod.mist.biv<-"model{
# Likelihood:
for (i in 1:N){
yprev[i,1:D]<-y[i,1:D]
y[i,1:D] ~ dmnorm(muOfClust[clust[i],],tauOfClust)
clust[i] ~ dcat(pClust[1:k] )
}
# Prior:
for (g in 1:k) {
muOfClust[g,1:D] ~ dmnorm(mu_0[],S2[,])}
tauOfClust[1:D,1:D] ~ dwish(S3[,],3)
Sigma[1:D,1:D] <- inverse(tauOfClust[,])
pClust[1:k] ~ ddirch(alpha)
}"
init1.biv <- list()
for (s in 1:chains)
init1.biv[[s]] <- dump.format(list(muOfClust=mu_inits,
tauOfClust= 15*diag(D),
pClust=rep(1/k,k), clust=clust_inits))
moni.biv <- c("clust","muOfClust","tauOfClust","pClust")
mod   <- mod.mist.biv
dati  <- dati.biv
init1 <- init1.biv
moni  <- moni.biv
# Jags execution
ogg.jags <- run.jags(model=mod, data=dati, monitor=moni,
inits=init1, n.chains=chains,plots=FALSE, thin=1,
sample=nMC, burnin=burn)
library(runjags)
library(rjags)
# Jags execution
ogg.jags <- run.jags(model=mod, data=dati, monitor=moni,
inits=init1, n.chains=chains,plots=FALSE, thin=1,
sample=nMC, burnin=burn)
chains <- 3
# Jags execution
ogg.jags <- run.jags(model=mod, data=dati, monitor=moni,
inits=init1, n.chains=chains,plots=FALSE, thin=1,
sample=nMC, burnin=burn)
burn <- 100
# Jags execution
ogg.jags <- run.jags(model=mod, data=dati, monitor=moni,
inits=init1, n.chains=chains,plots=FALSE, thin=1,
sample=nMC, burnin=burn)
printed <- print(add.summary(ogg.jags, vars= c("muOfClust",
"tauOfClust",
"pClust")))
# Extraction
ris <- ogg.jags$mcmc[[1]]
# Post- process of the chains----------------------
group <- ris[-(1:burn),grep("clust[",colnames(ris),fixed=TRUE)]
# only the variances
tau <- sqrt( (1/ris[-(1:burn),grep("tauOfClust[",colnames(ris),fixed=TRUE)])[,c(1,4)])
prob.st <- ris[-(1:burn),grep("pClust[",colnames(ris),fixed=TRUE)]
M <- nrow(group)
H <- list()
mu_pre_switch_compl <- array(rep(0, M*D*k), dim=c(M,D,k))
dim(mu_pre_switch_compl)
ris[-(1:burn),grep("muOfClust",colnames(ris),fixed=TRUE)]
head(ris[-(1:burn),grep("muOfClust",colnames(ris),fixed=TRUE)])
for (i in 1:k){
H[[i]] <- ris[-(1:burn),grep("muOfClust",colnames(ris),fixed=TRUE)][,c(i,i+k)]
}
mu_pre_switch_compl <- array(rep(0, M*D*k), dim=c(M,D,k))
for (i in 1:k){
H[[i]] <- ris[-(1:burn),grep("muOfClust",colnames(ris),fixed=TRUE)][,c(i,i+k)]
}
head(ris[-(1:burn),grep("muOfClust",colnames(ris),fixed=TRUE)])
H[Ã¨1]
H[[1]]
head(H[[1]])
ris[-(1:burn),grep("muOfClust",colnames(ris),fixed=TRUE)]
head(ris[-(1:burn),grep("muOfClust",colnames(ris),fixed=TRUE)])
i
i=1
k
seq(i, i+k)
d
D
(i+k)
i
(i+k)*(D-2)
(i+k)*(D-1)
(i+k*(D-2))
(i+k*(D-1))
head(ris[-(1:burn),grep("muOfClust",colnames(ris),fixed=TRUE)])
mu_pre_switch_compl <- array(rep(0, M*D*k), dim=c(M,D,k))
for (i in 1:k){
H[[i]] <- ris[-(1:burn),
grep(paste("muOfClust[",i, sep=""),
colnames(ris),fixed=TRUE)]
#[,c(i,i+k)]
}
H[[1]]
paste("muOfClust[",i, sep="")
mu_pre_switch_compl <- array(rep(0, M*D*k), dim=c(M,D,k))
for (i in 1:k){
H[[i]] <- ris[-(1:burn),
grep(paste("muOfClust[",i, sep=""),
colnames(ris),fixed=TRUE)]
#[,c(i,i+k)]
}
for (i in 1:k){
mu_pre_switch_compl[,,i] <- as.matrix(H[[i]])
}
mu_pre_switch_compl
# Discard iterations
numeffettivogruppi <- apply(group,1,FUN = function(x) length(unique(x)))
ris <- ris[numeffettivogruppi==k,]
true.iter <- nrow(ris)
if (sum(numeffettivogruppi==k)==0){
return(print("MCMC has not never been able to identify the required number of groups and the process has been interrupted"))
#return(1)
}else{
L<-list()
mu_pre_switch <- array(rep(0, true.iter*D*k), dim=c(true.iter,D,k))
for (i in 1:k){
L[[i]] <- ris[,grep("muOfClust",colnames(ris),fixed=TRUE)][,c(i,i+k)]
}
for (i in 1:k){
mu_pre_switch[,,i] <- as.matrix(L[[i]])
}
}
setwd("~/GitHub/pivmet")
if (sum(numeffettivogruppi==k)==0){
return(print("MCMC has not never been able to identify the required number of groups and the process has been interrupted"))
#return(1)
}else{
L<-list()
mu_pre_switch <- array(rep(0, true.iter*D*k), dim=c(true.iter,D,k))
for (i in 1:k){
L[[i]] <- ris[,grep(paste("muOfClust[", i, sep=""),
colnames(ris),fixed=TRUE)]
#[,c(i,i+k)]
}
for (i in 1:k){
mu_pre_switch[,,i] <- as.matrix(L[[i]])
}
}
dim(mu_pre_switch)
group <- ris[,grep("clust[",colnames(ris),fixed=TRUE)]
FreqGruppiJags <- table(group)
model_code <- mod.mist.biv
mcmc_mean_raw = mu_pre_switch_compl
mcmc_weight_raw = prob.st
mcmc_sd_raw = tau
tau <- sqrt( (1/ris[,grep("tauOfClust[",colnames(ris),fixed=TRUE)])[,c(1,4)])
prob.st <- ris[,grep("pClust[",colnames(ris),fixed=TRUE)]
mu <- mu_pre_switch
library(pivmet)
N  <- 2000
k  <- 3
D <- 3
M1 <- c(-45,8,2)
M2 <- c(45,.1,3)
M3 <- c(100,8,4)
Mu <- rbind(M1,M2,M3)
Sigma.p1 <- diag(D)
Sigma.p2 <- 20*diag(D)
W   <- c(0.2,0.8)
sim <- piv_sim(N = N, k = k, Mu = Mu, Sigma.p1 = Sigma.p1,
Sigma.p2 = Sigma.p2, W = W)
piv_MCMC(y=sim$y, k=3, nMC=300)
N  <- 2000
k  <- 3
D <- 2
M1 <- c(-45,8)
M2 <- c(45,.1)
M3 <- c(100,8)
Mu <- rbind(M1,M2,M3)
Sigma.p1 <- diag(D)
Sigma.p2 <- 20*diag(D)
W   <- c(0.2,0.8)
sim <- piv_sim(N = N, k = k, Mu = Mu, Sigma.p1 = Sigma.p1,
Sigma.p2 = Sigma.p2, W = W)
res <- piv_MCMC(y=sim$y, k=3, nMC = 300)
rel <- piv_rel(res)
res <- piv_MCMC(y=sim$y, k=3, nMC = 300, software = "rstan")
help(piv_sim)
N  <- 2000
k  <- 3
D <- 5
M1 <- c(-45,8,1,2,3)
M2 <- c(45,.1,1,2,3)
M3 <- c(100,8,1,2,3)
Mu <- rbind(M1,M2,M3)
Sigma.p1 <- diag(D)
Sigma.p2 <- 20*diag(D)
W   <- c(0.2,0.8)
sim <- piv_sim(N = N, k = k, Mu = Mu, Sigma.p1 = Sigma.p1,
Sigma.p2 = Sigma.p2, W = W)
sim$y
res <- piv_MCMC(y=sim$y, k =3, nMC = 300  )
sim$y
res <- piv_MCMC(y=sim$y, k =3, nMC = 300  )
N  <- 2000
k  <- 3
D <- 3
M1 <- c(-45,8,1)
M2 <- c(45,.1,1)
M3 <- c(100,8,1)
Mu <- rbind(M1,M2,M3)
Sigma.p1 <- diag(D)
Sigma.p2 <- 20*diag(D)
W   <- c(0.2,0.8)
sim <- piv_sim(N = N, k = k, Mu = Mu, Sigma.p1 = Sigma.p1,
Sigma.p2 = Sigma.p2, W = W)
res <- piv_MCMC(y=sim$y, k =3, nMC = 300  )
N  <- 2000
k  <- 3
D <- 4
M1 <- c(-45,8,1,3)
M2 <- c(45,.1,1,4)
M3 <- c(100,8,1,1)
Mu <- rbind(M1,M2,M3)
Sigma.p1 <- diag(D)
Sigma.p2 <- 20*diag(D)
W   <- c(0.2,0.8)
sim <- piv_sim(N = N, k = k, Mu = Mu, Sigma.p1 = Sigma.p1,
Sigma.p2 = Sigma.p2, W = W)
res <- piv_MCMC(y=sim$y, k =3, nMC = 300  )
is.matrix(sim$y)
dim(sim$y)[2]
D
mu_0 <- rep(0, D)
S2 <- diag(D)/100000
S3 <- diag(D)/100000
alpha <- rep(1,k)
y <- sim$y
N
# Data
dati.biv <- list(y = y, N = N, k = k, D = D,
S2= S2, S3= S3, mu_0=mu_0,
alpha = alpha)
# Model
mod.mist.biv<-"model{
# Likelihood:
for (i in 1:N){
yprev[i,1:D]<-y[i,1:D]
y[i,1:D] ~ dmnorm(mu[clust[i],],tau)
clust[i] ~ dcat(theta[1:k] )
}
# Prior:
for (g in 1:k) {
mu[g,1:D] ~ dmnorm(mu_0[],S2[,])}
tau[1:D,1:D] ~ dwish(S3[,],3)
Sigma[1:D,1:D] <- inverse(tau[,])
theta[1:k] ~ ddirch(alpha)
}"
init1.biv <- list()
chains <- 3
init1.biv <- list()
for (s in 1:chains)
init1.biv[[s]] <- dump.format(list(mu=mu_inits,
tau= 15*diag(D),
theta=rep(1/k,k), clust=clust_inits))
moni.biv <- c("clust","mu","tau","theta")
mod   <- mod.mist.biv
dati  <- dati.biv
init1 <- init1.biv
moni  <- moni.biv
# Jags execution
ogg.jags <- run.jags(model=mod, data=dati, monitor=moni,
inits=init1, n.chains=chains,plots=FALSE, thin=1,
sample=nMC, burnin=burn)
init1
init1.biv
for (s in 1:chains)
init1.biv[[s]] <- dump.format(list(mu=mu_inits,
tau= 15*diag(D),
theta=rep(1/k,k), clust=clust_inits))
init1.biv
mu_inits
15*diag(D)
theta=rep(1/k,k)
dump.format(list(mu=mu_inits,
tau= 15*diag(D),
theta=rep(1/k,k), clust=clust_inits))
init1.biv <- list()
init1.biv <- list()
for (s in 1:chains){
init1.biv[[s]] <- dump.format(list(mu=mu_inits,
tau= 15*diag(D),
theta=rep(1/k,k), clust=clust_inits))
}
init1.biv
moni.biv <- c("clust","mu","tau","theta")
mod   <- mod.mist.biv
dati  <- dati.biv
init1 <- init1.biv
moni  <- moni.biv
# Jags execution
ogg.jags <- run.jags(model=mod, data=dati, monitor=moni,
inits=init1, n.chains=chains,plots=FALSE, thin=1,
sample=nMC, burnin=burn)
