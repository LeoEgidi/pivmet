length(tt)
set.seed(2)
n=150
edf_beta<-ecdf(rbeta(n, 3,4))
tt<-seq(from=0, to=1, by=0.01)
plot(edf_beta, verticals=TRUE, do.p=FALSE, main="ECDF and CDF")
lines(tt, pbeta(tt,3,4), col=2, lty=2, lwd=2)
help("qqnorm")
y <- rt(200, df = 5)
qqnorm(y); qqline(y, col = 2)
qqplot(y, rt(300, df = 5))
y <- rt(200, df = 5)
qqnorm(y); qqline(y, col = 2)
qqplot(y, rt(300, df = 5))
help("qqnorm")
y <- rt(200, df = 5)
qqnorm(y); qqline(y, col = 2)
y <- rnorm(200, 0,1)
qqnorm(y); qqline(y, col = 2)
y <- rnorm(200, 2,5)
qqnorm(y); qqline(y, col = 2)
set.seed(2)
par(mfrow=c(1,2))
n=50
y=rbeta(n, 3,4)
edf_beta<-ecdf(y)
tt<-seq(from=0, to=1, by=0.01)
plot(edf_beta, verticals=TRUE, do.p=FALSE, main="ECDF and CDF: n=50")
lines(tt, pbeta(tt,3,4), col=2, lty=2, lwd=2)
n2=500
y2=rbeta(n2, 3,4)
edf_beta2<-ecdf(y2)
tt<-seq(from=0, to=1, by=0.01)
plot(edf_beta2, verticals=TRUE, do.p=FALSE, main="ECDF and CDF: n=500")
lines(tt, pbeta(tt,3,4), col=2, lty=2, lwd=2)
qqplot(qbeta(ppoints(n),3,4),y,
main = expression("Q-Q plot for" ~~ {beta}(3,4)))
qqplot(qbeta(ppoints(n),3,4),y,
main = "Q-Q plot for Beta(3,4)"  )))
qqplot(qbeta(ppoints(n),3,4),y,
main = "Q-Q plot for Beta(3,4)"  ))
qqplot(qbeta(ppoints(n),3,4),y,
main = "Q-Q plot for Beta(3,4): n=50")
qqline(y, distribution = function(p) qbeta(p, 3,4),
prob = c(0, 1), col = 2)
install.packages("DAAG")
install.packages("DAAG")
install.packages("DAAG")
install.packages("DAAG")
install.packages("DAAG")
install.packages(DAAG)
install.packages("DAAG")
p=0.5; size1=10; size2=50
#normal approximation
x <- rnorm(size1, size1*p, sqrt(size1*p*(1-p)) )
pnorm(x, size1*p, sqrt(size1*p*(1-p)))
x <- rnorm(size1, size1*p, sqrt(size1*p*(1-p)) )
prob_norm <- pnorm(x, size1*p, sqrt(size1*p*(1-p)))
plot(x, prob_norm, type="h", main="n=10", xlab="x", ylab="f(x)", xlim=c(1,10),
cex.lab=1.5)
size1*p
x <- rnorm(size1, size1*p, sqrt(size1*p*(1-p)) )
prob_norm <- dnorm(x, size1*p, sqrt(size1*p*(1-p)))
plot(x, prob_norm, type="h", main="n=10", xlab="x", ylab="f(x)", xlim=c(1,10),
cex.lab=1.5)
help(dbinom)
x <- rnorm(size1, size1*p, sqrt(size1*p*(1-p)) )
prob_norm <- dnorm(x, size1*p, sqrt(size1*p*(1-p)))
prob_bin <- dbinom(x, size1,p)
plot(x, prob_bin, type="h", main="n=10", xlab="x", ylab="f(x)", xlim=c(1,10),
cex.lab=1.5, col="red")
curve(dnorm(x, size1*p, sqrt(size1*p*(1-p))), add=TRUE)
x <- rnorm(size1, size1*p, sqrt(size1*p*(1-p)) )
prob_norm <- dnorm(x, size1*p, sqrt(size1*p*(1-p)))
prob_bin <- dbinom(x, size1,p)
plot(x, prob_bin, type="h", main="n=10", xlab="x", ylab="f(x)", xlim=c(1,10),
cex.lab=1.5, col="red")
curve(dnorm(x, size1*p, sqrt(size1*p*(1-p))))
curve(dnorm(x, size1*p, sqrt(size1*p*(1-p))), xlim=c(1,10))
lines(prob_bin, type="h", main="n=10", xlab="x", ylab="f(x)", xlim=c(1,10),
cex.lab=1.5, col="red")
plot(prob_bin, type="h", main="n=10", xlab="x", ylab="f(x)", xlim=c(1,10),
cex.lab=1.5, col="red")
prob_bin <- dbinom(x, size1,p)
prob_bin
prob_bin <- dbinom(seq(0:10), size1,p)
prob_bin
x <- rnorm(size1, size1*p, sqrt(size1*p*(1-p)) )
#prob_norm <- dnorm(x, size1*p, sqrt(size1*p*(1-p)))
prob_bin <- dbinom(seq(0:10), size1,p)
curve(dnorm(x, size1*p, sqrt(size1*p*(1-p))), xlim=c(0,10))
lines(prob_bin, type="h", main="n=10", xlab="x", ylab="f(x)", xlim=c(1,10),
cex.lab=1.5, col="red")
x <- rnorm(size1, size1*p, sqrt(size1*p*(1-p)) )
prob_bin <- dbinom(seq(0:10), size1,p)
curve(dnorm(x, size1*p, sqrt(size1*p*(1-p))), xlim=c(0,10), xlab="x", ylab="f(x)")
lines(prob_bin, type="h", main="n=10", xlim=c(1,10),
cex.lab=1.5, col="red")
help(cars)
knitr::knit("Lab12.Rmd", tangle = TRUE, output ="foo.R") )
knitr::knit("Lab12.Rmd", tangle = TRUE, output ="foo.R")
library(knitr)
library(rmarkdown)
knitr::knit("Lab12.Rmd", tangle = TRUE, output ="foo.R")
Musicians <- c( "Selena Gomez",  "Ariana Grande", "Beyonce" , "Taylor Swift",  "Justin Bieber", "Nicki Minaj", "Nicola Gennaro", "Nilson", "Ginevra Carbone")
Others <- c("Cristiano Ronaldo", "Kim Kardashian",  "Kylie Jenner", "Dwayne Johnson", "Neymar", "Lionel Messi",
"Kendall Jenner", "Kourtney Kardashian", "Kevin Hart",)
n1 <- length(Musicians)
n2 <- length(Others)
Musicians <- c( "Selena Gomez",  "Ariana Grande", "Beyonce" , "Taylor Swift",  "Justin Bieber", "Nicki Minaj", "Nicola Gennaro", "Nilson", "Ginevra Carbone")
Others <- c("Cristiano Ronaldo", "Kim Kardashian",  "Kylie Jenner", "Dwayne Johnson", "Neymar", "Lionel Messi",
"Kendall Jenner", "Kourtney Kardashian", "Kevin Hart")
n1 <- length(Musicians)
n2 <- length(Others)
Followers_M<- c(135, 118, 113, 107,  98,  86, 1, 923*10^(-6) )
Followers_O <- c(123, 110, 106, 103,  91,  89,  89,  62,  58)
t <- t.test(Followers_M, Followers_O, mu = 0, alternative ="greater", var.equal =TRUE)
t
n <- 50
K <- 4
M <- 6
y <- matrix(0, M, n )
# generate the values
for (m in 1:M){
y[m, ] <- sample(1:K, n, replace=TRUE, prob = c( 7/16, 5/16, 3/16, 1/16) )
}
observed_matrix <- apply( y,1, table)
chisq.test(observed_matrix, p = c( 7/16, 5/16, 3/16, 1/16) )
n <- 50
K <- 4
M <- 6
y <- matrix(0, M+1, n )
# generate the values
for (m in 1:M){
y[m, ] <- sample(1:K, n, replace=TRUE, prob = c( 7/16, 5/16, 3/16, 1/16) )
}
y[7, ] <- sample(1:K, n, replace=TRUE, prob = c( 2/16, 3/16, 5/16, 6/16) )
observed_matrix <- apply( y,1, table)
chisq.test(observed_matrix, p = c( 7/16, 5/16, 3/16, 1/16) )
set.seed(1)
X <- 1:100
Y <- rnorm(length(X), 2*X + 10, 1)
N <- length(X)
model <- "
model {
for(i in 1 : N){ #data# N
Y[i] ~ dnorm(true.y[i], precision) #data# Y
true.y[i] <- (coef * X[i]) + int #data# X
}
coef ~ dunif(-1000,1000)
int ~ dunif(-1000,1000)
precision ~ dexp(1)
#inits# coef, int, precision
#monitor# coef, int, precision
}"
# A function to return initial values for each chain:
coef <- function(chain) return(switch(chain, "1"= -10, "2"= 10))
int <- function(chain) return(switch(chain, "1"= -10, "2"= 10))
precision <- function(chain) return(switch(chain, "1"= 0.01, "2"= 100))
init1 <- list(  coef=rnorm(1), int=rnorm(1), precision=runif(1))
init2 <- list(  coef=rnorm(1), int=rnorm(1), precision=runif(1))
# Run the simulation:
results <- run.jags(model, inits = list(init1, init2),  n.chains = 2)
library(runjags)
library(rjags)
set.seed(1)
X <- 1:100
Y <- rnorm(length(X), 2*X + 10, 1)
N <- length(X)
model <- "
model {
for(i in 1 : N){ #data# N
Y[i] ~ dnorm(true.y[i], precision) #data# Y
true.y[i] <- (coef * X[i]) + int #data# X
}
coef ~ dunif(-1000,1000)
int ~ dunif(-1000,1000)
precision ~ dexp(1)
#inits# coef, int, precision
#monitor# coef, int, precision
}"
# A function to return initial values for each chain:
coef <- function(chain) return(switch(chain, "1"= -10, "2"= 10))
int <- function(chain) return(switch(chain, "1"= -10, "2"= 10))
precision <- function(chain) return(switch(chain, "1"= 0.01, "2"= 100))
init1 <- list(  coef=rnorm(1), int=rnorm(1), precision=runif(1))
init2 <- list(  coef=rnorm(1), int=rnorm(1), precision=runif(1))
# Run the simulation:
results <- run.jags(model, inits = list(init1, init2),  n.chains = 2)
save(results, file="ris.RData", compress="xz")
log_lik_weibull <- function( data, param){
-sum(dweibull(data, shape = param[1], scale = param[2], log = TRUE))
}
y <- c(155.9, 200.2, 143.8, 150.1,152.1, 142.2, 147, 146, 146, 170.3, 148, 140, 118, 144, 97)
theta <- function(omega) exp(omega)
log_lik_weibull_rep <- function(data, param) log_lik_weibull(data, theta(param))
weib.y.nlm<-suppressWarnings(nlm(log_lik_weibull_rep,c(0,0),hessian=T,data=y))
varOmega<-diag(solve(weib.y.nlm$hessian))
print("Variance for the estimator omega:")
weib.y.nlm
exp(weib.y.nlm$estimate)
help("norm")
dt_ls(x, df, mu, sigma) =
1/sigma * dt((x - mu)/sigma, df)
dpois_ls(x, df, mu, sigma) =
dpois((x - mu))
dpois_ls(x,  mu) =function(x){
dpois((x - mu))}
dpois_ls =function(x, mu){
dpois((x - mu))}
dpois_ls(2,4)
dpois_ls =function(x, mu){
dpois((x - mu))}
245*1.14
280/6
171+144
171/6
library(rstanarm)
help("stan_glmer")
740/16
library(devtools)
install.packages("devtools")
library(devtools)
library("devtools", lib.loc="~/R/win-library/3.4")
remove.packages("devtools", lib="~/R/win-library/3.4")
install.packages("devtools")
library(devtools)
library("devtools")
.libPaths()
.libPaths("C:/Users/leonardo/Documents/R/win-library/3.4")
library(devtools)
library(devtoolsÃ¹)
library(devtools)
install_github("leoegidi/pivmet")
help(pivmet)
library("pivmet", lib.loc="~/R/win-library/3.4")
help(pivmet)
N <- 200
k <- 4
nMC <- 1000
M1 <-c(-.5,8)
M2 <- c(25.5,.1)
M3 <- c(49.5,8)
M4 <- c(63.0,.1)
Mu <- matrix(rbind(M1,M2,M3,M4),c(4,2))
stdev=cbind(rep(1,k), rep(200,k))
Sigma.p1 <- matrix(c(1,0,0,1), nrow=2, ncol=2)
Sigma.p2 <- matrix(c(200,0,0,200), nrow=2, ncol=2)
W <- c(0.2,0.8)
sim <- sim_mixture(N,k,Mu, stdev, Sigma.p1,Sigma.p2,W)
output_bayes <- bayesMCMC(sim$y, k, nMC)
install_github("leoegidi/pivmet")
N <- 200
k <- 4
nMC <- 1000
M1 <-c(-.5,8)
M2 <- c(25.5,.1)
M3 <- c(49.5,8)
M4 <- c(63.0,.1)
Mu <- matrix(rbind(M1,M2,M3,M4),c(4,2))
stdev=cbind(rep(1,k), rep(200,k))
Sigma.p1 <- matrix(c(1,0,0,1), nrow=2, ncol=2)
Sigma.p2 <- matrix(c(200,0,0,200), nrow=2, ncol=2)
W <- c(0.2,0.8)
sim <- sim_mixture(N,k,Mu, stdev, Sigma.p1,Sigma.p2,W)
output_bayes <- bayesMCMC(sim$y, k, nMC)
library(pivmet)
library("devtools")
install_github("leoegidi/pivmet")
library(pivmet)
remove.packages("pivmet", lib="~/R/win-library/3.4")
library(devtools)
install_github("leoegidi/pivmet")
library(pivmet)
??bayesMCMC
remove.packages("pivmet", lib="~/R/win-library/3.4")
LIBRARY(DEVTOOLS)
library(devtools)
install_github("leoegidi/pivmet")
library(pivmet)
help("pivotal_relabelling")
diff<- funcion(x){dnorm(x,1,1000)-dnorm(x,1,1)}
diff<- function(x){dnorm(x,1,1000)-dnorm(x,1,1)}
curve(diff)
curve(diff, -10,10)
diff<- function(x){dnorm(x,1,100)-dnorm(x,1,1)}
curve(diff, -10,10)
setwd("C:/Users/leonardo/Desktop")
library(devtools)
install_github("leoegidi/pivmet")
library(pivmet)
.rs.restartR()
library(pivmet)
help("pivotal_relabelling")
setwd("~/GitHub/pivmet")
install_github("leoegidi/pivmet")
.rs.restartR()
librry(pivmet)
library(pivmet)
help("pivotal_relabelling")
setwd("~/GitHub/pivmet")
library(rprojroot)
root <- rprojroot::is_r_package
readLines(root$find_file("DESCRIPTION"), 3)
root_file <- root$make_fix_file()
root_file
withr::with_dir(
"../..",
readLines(root_file("DESCRIPTION"), 3)
)
root_file <- root$make_fix_file("C:\\Users\\User Name\\...")
root_file <- root$make_fix_file("C:\\Users\\leonardo\\...")
root_file <- root$make_fix_file("C:\\Utenti\\leonardo\\...")
root_file()
ir(find_root(has_file("DESCRIPTION")))
dir(find_root(has_file("DESCRIPTION")))
rel_path_from_root <- "R/mus.R"
rel_path_from_root
has_file("DESCRIPTION")
rel_path_from_root <- find_root_file("R", "mus.R", criterion = has_file("DESCRIPTION"))
rel_path_from_root
file.exists(rel_path_from_root)
library(pivmet)
.rs.restartR()
library(pivmet)
help("pivotal_relabelling")
library(devtools)
install_github("leoegidi/pivmet")
library(pivmet)
help("pivotal_relabelling")
install_github("leoegidi/pivmet")
library(devtools)
install_github("leoegidi/pivmet")
library(pivmet)
??pivotal_relabelling
setwd("C:/Users/leonardo/Desktop")
setwd("C:/Users/leonardo/Desktop")
setwd("~/GitHub/pivmet")
remove.packages("pivmet", lib="~/R/win-library/3.4")
library(devtools)
install_github("leoegidi/pivmet")
library(pivmet)
help("pivotal_relabelling")
library(pivmet)
library(pivmet)
devtools::load_all(".")
library(pivmet)
devtools::load_all(".")
library(pivmet)
install_github("leoegidi/pivmet")
library(devtools)
install_github("leoegidi/pivmet")
install_github("leoegidi/pivmet")
library(pivmet)
library(pivmet)
load_all()
devtools::load_all(".")
library(pivmet)
devtools::load_all(".")
library(pivmet)
library("pivmet", lib.loc="~/R/win-library/3.4")
remove.packages("pivmet", lib="~/R/win-library/3.4")
library(pivmet)
devtools::document()
library(pivmet)
N <- 250
nMC <- 2500
k <- 3
p <- rep(1/k,k)
x <- 3
stdev <- cbind(rep(1,k), rep(200,k))
Mu <- seq(-trunc(k/2)*x,trunc(k/2)*x,length=k)
W <- c(0.2,0.8)
sim <- sim_mixture(N,k,Mu,stdev,W=W)
output_bayes <- bayesMCMC(sim$y, k, nMC)
relab_est <-
pivotal_relabelling(mu_switch = output_bayes$mu_switch,
group = output_bayes$groupPost,
clustering= output_bayes$clust_sel,
Mu=output_bayes$Mu,
nMC = nMC)
plot_pivotal(y= sim$y,
est = relab_est$mu_rel_median,
chains=relab_est$mu_rel_complete,
type="chains",
mu_switch=output_bayes$mu_switch,
n.iter=relab_est$Final_it,
true.means= output_bayes$Mu)
devtools::document()
library(pivmet)
N <- 200
k <- 3
M1 <- c(-.5,8)
M2 <- c(25.5,.1)
M3 <- c(49.5,8)
Mu <- matrix(rbind(M1,M2,M3,M3),c(k,2))
stdev <- cbind(rep(1,k), rep(200,k))
Sigma.p1 <- matrix(c(stdev[1,1],0,0,stdev[1,1]),
nrow=2, ncol=2)
Sigma.p2 <- matrix(c(stdev[1,2],0,0,stdev[1,2]),
nrow=2, ncol=2)
W <- c(0.2,0.8)
sim <- sim_mixture(N,k,Mu,stdev,Sigma.p1,Sigma.p2,W)
devtools::document()
library(pivmet)
devtools::document()
devtools::document()
library(pivmet)
Bivariate mixture simulation with three components
N <- 200
k <- 3
M1 <- c(-.5,8)
M2 <- c(25.5,.1)
M3 <- c(49.5,8)
Mu <- matrix(rbind(M1,M2,M3),c(k,2))
stdev <- cbind(rep(1,k), rep(200,k))
Sigma.p1 <- matrix(c(stdev[1,1],0,0,stdev[1,1]),
nrow=2, ncol=2)
Sigma.p2 <- matrix(c(stdev[1,2],0,0,stdev[1,2]),
nrow=2, ncol=2)
W <- c(0.2,0.8)
sim <- piv_sim(N,k,Mu,stdev,Sigma.p1,Sigma.p2,W)
sim$y
devtools::document()
library(pivmet)
N   <- 200
k   <- 4
nMC <- 1000
M1  <-c(-.5,8)
M2  <- c(25.5,.1)
M3  <- c(49.5,8)
M4  <- c(63.0,.1)
Mu  <- matrix(rbind(M1,M2,M3,M4),c(4,2))
stdev    <- cbind(rep(1,k), rep(200,k))
Sigma.p1 <- matrix(c(stdev[1,1],0,0,stdev[1,1]), nrow=2, ncol=2)
Sigma.p2 <- matrix(c(stdev[1,2],0,0,stdev[1,2]), nrow=2, ncol=2)
W <- c(0.2,0.8)
sim <- piv_sim(N,k,Mu, stdev, Sigma.p1,Sigma.p2,W)
res <- piv_MCMC(sim$y, k, nMC)
devtools::document()
library(pivmet)
data(fish)
y <- fish[,1]
k <- 5
nMC <- 5000
res <- piv_MCMC(y, k, nMC)
library(bayesmix)
data(fish)
y <- fish[,1]
k <- 5
nMC <- 5000
res <- piv_MCMC(y, k, nMC)
devtools::(document())
devtools::document()
devtools::document()
library(pivmet)
N <- 200
k <- 3
nMC <- 5000
M1  <- c(-.5,8)
M2  <- c(25.5,.1)
M3  <- c(49.5,8)
Mu  <- matrix(rbind(M1,M2,M3),c(k,2))
stdev <- cbind(rep(1,k), rep(200,k))
Sigma.p1 <- matrix(c(stdev[1,1],0,0,stdev[1,1]),
nrow=2, ncol=2)
Sigma.p2 <- matrix(c(stdev[1,2],0,0,stdev[1,2]),
nrow=2, ncol=2)
W <- c(0.2,0.8)
sim <- sim_mixture(N,k,Mu,stdev,Sigma.p1,Sigma.p2,W)
res <- bayesMCMC(sim$y, k, nMC)
rel <- piv_rel(mu_switch=res$mu_switch,
group=res$groupPost,
clustering=res$clust_sel,
Mu=res$Mu,
nMC = nMC)
plot_pivotal(y= sim$y,
est = rel$mu_rel_median,
chains=rel$mu_rel_complete,
type="chains",
mu_switch=res$mu_switch,
n.iter=rel$Final_it,
true.means= res$Mu)
devtools::document()
library(pivmet)
N <- 200
k <- 3
nMC <- 5000
M1  <- c(-.5,8)
M2  <- c(25.5,.1)
M3  <- c(49.5,8)
Mu  <- matrix(rbind(M1,M2,M3),c(k,2))
stdev <- cbind(rep(1,k), rep(200,k))
Sigma.p1 <- matrix(c(stdev[1,1],0,0,stdev[1,1]),
nrow=2, ncol=2)
Sigma.p2 <- matrix(c(stdev[1,2],0,0,stdev[1,2]),
nrow=2, ncol=2)
W <- c(0.2,0.8)
sim <- piv_sim(N,k,Mu,stdev,Sigma.p1,Sigma.p2,W)
res <- piv_MCMC(sim$y, k, nMC)
rel <- piv_rel(mu_switch=res$mu_switch,
group=res$groupPost,
clustering=res$clust_sel,
Mu=res$Mu,
nMC = nMC)
plot_pivotal(y= sim$y,
est = rel$mu_rel_median,
chains=rel$mu_rel_complete,
type="chains",
mu_switch=res$mu_switch,
n.iter=rel$Final_it,
true.means= res$Mu)
