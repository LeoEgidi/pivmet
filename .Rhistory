x[i,]=c(rnorm(1,v[i], 0.1), rnorm(1,w[i], 0.1  ) )
}
for (i in 11:50){
x[i,]=c(rnorm(1,v[i], 0.5), rnorm(1,w[i], 0.5  ) )
}
for (i in 51:90  ){
x[i,]=c(rnorm(1, v2[i-50  ], 0.5),rnorm(1, sort(w, decreasing=TRUE)[i-50], 0.5)     )
}
for ( i in 91:100){
x[i,]=c(rnorm(1, v2[i-50  ], 0.1),rnorm(1, sort(w, decreasing=TRUE)[i-50], 0.1)     )
}
for (i in 101:110   ){
x[i,]=c(  rnorm(1, v[i-100] , 0.1), rnorm(1,  sort(v2, decreasing=TRUE)[i-100], 0.1 )    )
}
for (i in 111:150){
x[i,]=c(  rnorm(1, v[i-100] , 0.5), rnorm(1,  sort(v2, decreasing=TRUE)[i-100], 0.5 )    )
}
for (i in 151:190){
x[i,]=c(rnorm(1, v2[i-150], 0.5    ), rnorm(1, v2[i-150], 0.5    )            )
}
for (i in 191:200){
x[i,]=c(rnorm(1, v2[i-150], 0.1    ), rnorm(1, v2[i-150], 0.1    )            )
}
x[201,]=c(-1,10)
x[202,]=c(-1,-1)
x[203,]=c(10,10)
x[204,]=c(10,-1)
#par(mfrow=c(1,1))
#plot(x)
n=n+4
#Assegno gruppi in maniera fittizia con un kmeans
(cl <- KMeans(x, k))
#gruppovero=rep(c(1:k), each=n/k)
#compute dissimilarity:calcolo la compresenza per ogni unitÃ  statistica
H=1000
a=matrix(NA, H, n)
gruppi=matrix(NA, H,n)
for (h in 1:H){
a[h,]=KMeans(x,k)$cluster
}
sim_matr=matrix(1, n,n)
for (i in 1:(n-1)){
for (j in (i+1):n){
sim_matr[i,j]=sum(a[,i]==a[,j])/H
sim_matr[j,i]=sim_matr[i,j]
}
}
sum(sim_matr==0)
#MUS
mus_res=MUS_alg(sim_matr, cl$cluster, 5)
pivots=mus_res$massimi
x[pivots[1],]
x[pivots[2],]
#x[pivots[3],]
#x[pivots[4],]
#par(mfrow=c(2,2))
#pdf(file="dati_veri.pdf")
#plot(x, col = gruppovero, bg=gruppovero, pch=21, xlab="y[,1]", ylab="y[,2]", cex.lab=1.5,
#main="True data")
#dev.off()
par(mfrow=c(1,2))
#pdf(file="clusters_random.pdf")
plot(x, col = cl$cluster, bg=cl$cluster, pch=21, xlab="y[,1]", ylab="y[,2]",
cex.lab=1.5,main="K-means")
points(cl$centers, col = 1:k, pch = 8, cex = 2)
#dev.off()
start=matrix(c(  as.double(x[pivots[1],]),
as.double(x[pivots[2],])
,
as.double(x[pivots[3],])
,
as.double(x[pivots[4],])
), k,2, byrow=TRUE)
d_mus=KMeans(x, centers=start)
d_random=KMeans(x,k)
#pdf(file="cluster_mus.pdf")
plot(x, col = d_mus$cluster, bg=d_mus$cluster, pch=21, xlab="y[,1]", ylab="y[,2]", cex.lab=1.5,
main="MUSK-means")
points(x[pivots[1],1], x[pivots[1],2], pch=0, col=1,cex=2)
points(x[pivots[2],1], x[pivots[2],2], pch=0, cex=2, col=2)
points(x[pivots[3],1], x[pivots[3],2], pch=0, cex=2, col=3)
points(x[pivots[4],1], x[pivots[4],2], pch=0, cex=2, col=4)
points(d_mus$centers, col = 1:k, pch = 8, cex = 2)
#dev.off()
ratio_random[l]=d_random$betweenss/d_random$totss
ratio_mus[l]=d_mus$betweenss/d_mus$totss
}
l
par(mfrow=c(1,1))
plot(ratio_mus, ratio_random, pch=21, bg=1,
#xlim=c(0.68,0.8), ylim=c(0.68,0.8),
xlab=expression(Q[MUS]), cex.lab=1.5, ylab="Q")
abline(b=1, a=0, col="red", lwd=2)
install.packages(c("devtools", "roxygen2", "testthat"))
library(devtools)
has_devel()
help(D)
D(x^2)
D(x^2, name=x)
D(expression(x^2), name=x)
D(expression(x^2), "x")
D(expression(lambda^2), "lambda")
mgf_poisson <- function(lambda,t)
return(exp(lambda*(exp(t)-1)))
```
mgf_poisson <- function(lambda,t){
return(exp(lambda*(exp(t)-1)))
}
mgf_poisson()
mgf_poisson(2,1)
mgf_poisson(2)
D(expr(mgf_poisson(2, 0)), "t")
D(expression(mgf_poisson(2, 0)), "t")
expression(mgf_poisson())
expression(mgf_poisson(2,1))
mgf_poisson <- function(lambda,t){
return(  expression(exp(lambda*(exp(t)-1))))
}
mgf_poisson(2,t)
mgf_poisson(2,1)
D(mgf_poisson(2,t), "t")
mgf_poisson <- function(lambda,t){
return( c(exp(lambda*(exp(t)-1)) , expression(exp(lambda*(exp(t)-1)))))
}
mgf_poisson(2,t)
mgf_poisson(2,9)
mgf_poisson <- function(lambda,t){
return( list(exp(lambda*(exp(t)-1)) , expression(exp(lambda*(exp(t)-1)))))
}
mgf_poisson(2,9)
value_mgf <- mgf_poisson(2,t)
mgf_poisson <- function(lambda,t){
return( list(exp(lambda*(exp(t)-1)) , expression(exp(lambda*(exp(t)-1)))))
}
mgf_poisson(2,t)
mgf_poisson(2,0)
value_mgf <- mgf_poisson(2,0)
D(value_mgf[[2]], "t")
D(expression(exp(lambda*(exp(t)-1))), "t")
mgf_poisson <- function(lambda,t){
return( list(exp(lambda * (exp(t) - 1)) * (lambda * exp(t)) , D(expression(exp(lambda*(exp(t)-1))), "t")))
}
mgf_poisson <- function(lambda,t){
return( list(exp(lambda * (exp(t) - 1)) * (lambda * exp(t)) , D(expression(exp(lambda*(exp(t)-1))), "t")))
}
mgf_poisson(2,0)
eval(  D(expression(exp(lambda*(exp(t)-1))), "t") )
eval(  D(expression(exp(lambda*(exp(t)-1))), "t") ,2,0)
help("eval")
eval(  D(expression(exp(lambda*(exp(t)-1))), "t") ,lambda=2,t=0)
eval(  D(expression(exp(lambda*(exp(t)-1))), "t") ,"t",0)
eval(  D(expression(exp(lambda*(exp(t)-1))), "t") )
lambda=
2
lambda=
2
eval(  D(expression(exp(lambda*(exp(t)-1))), "t") )
mEx <- expression(2^2^3); mEx; 1 + eval(mEx)
mEx <- expression(2^2^3);
1 + eval(mEx)
eval(D(expression(exp(lambda*(exp(t)-1))), "t"))
eval(D(expression(exp(lambda*(exp(t)-1)))))
eval(D(expression(exp(lambda*(exp(t)-1))), "t"))
eval(D(expression(exp(lambda*(exp(t)-1))), "t"))
t=0
eval(D(expression(exp(lambda*(exp(t)-1))), "t"))
mgf_poisson <- function(lambda,t){
values_mgf <- eval(D(expression(exp(lambda*(exp(t)-1))), "t"))
expression_mgf <- D(expression(exp(lambda*(exp(t)-1))), "t")
return( list( values_mgf,expression_mgf    ))
}
mfg(2,0)
mgf_poisson(2,0)
curve(dgamma(x,2,2), xlim=c(0,4))
n=1000; alpha=2; beta=2; sample_rep=1000
X=matrix(NA, n, sample_rep)
for (h in 1:n){
X[n,]=rexp(sample_rep, alpha)
}
sum_X=apply(X,1,sum)
sum_X
n=1000; alpha=2; beta=2; sample_rep=1000
X=matrix(NA, n, sample_rep)
for (h in 1:n){
X[h,]=rexp(sample_rep, alpha)
}
sum_X=apply(X,1,sum)
hist(sum_X, breaks=40)
curve(dgamma(x, alpha, n), add=TRUE)
curve(dgamma(x, n, alpha), col="red", lwd=2, add=TRUE)
hist(sum_X, breaks=40, density=TRUE)
curve(dgamma(x, n, alpha), col="red", lwd=2, add=TRUE)
hist(sum_X, breaks=40, density=TRUE)
help("hist")
hist(sum_X, breaks=40, probability=TRUE)
curve(dgamma(x, n, alpha), col="red", lwd=2, add=TRUE)
curve(dgamma(x, 5/2, 1/2))
curve(dgamma(x, 5/2, 1/2), xlim=c(0,4))
curve(dgamma(x, 5/2, 1/2), xlim=c(0,20))
curve(dchisq(x, 5/2), col="red", add=TRUE)
curve(dchisq(x, 5), col="red", add=TRUE)
integrate(x*dbeta(x,3,3))
help("integrate")
integrate(  x^2 )
expected_function <- function(x){
x*dbeta(x,2,2)
}
integrate(expected_function, 0,1)
expected_function <- function(x,a,b){
x*dbeta(x,a,b)
}
#use integrate function
integrate(expected_function, a=2, b=2, 0,1)
tt<-seq(from=-3, to=3, by=0.01)
length(tt)
set.seed(2)
n=150
edf_beta<-ecdf(rbeta(n, 3,4))
tt<-seq(from=0, to=1, by=0.01)
plot(edf_beta, verticals=TRUE, do.p=FALSE, main="ECDF and CDF")
lines(tt, pbeta(tt,3,4), col=2, lty=2, lwd=2)
help("qqnorm")
y <- rt(200, df = 5)
qqnorm(y); qqline(y, col = 2)
qqplot(y, rt(300, df = 5))
y <- rt(200, df = 5)
qqnorm(y); qqline(y, col = 2)
qqplot(y, rt(300, df = 5))
help("qqnorm")
y <- rt(200, df = 5)
qqnorm(y); qqline(y, col = 2)
y <- rnorm(200, 0,1)
qqnorm(y); qqline(y, col = 2)
y <- rnorm(200, 2,5)
qqnorm(y); qqline(y, col = 2)
set.seed(2)
par(mfrow=c(1,2))
n=50
y=rbeta(n, 3,4)
edf_beta<-ecdf(y)
tt<-seq(from=0, to=1, by=0.01)
plot(edf_beta, verticals=TRUE, do.p=FALSE, main="ECDF and CDF: n=50")
lines(tt, pbeta(tt,3,4), col=2, lty=2, lwd=2)
n2=500
y2=rbeta(n2, 3,4)
edf_beta2<-ecdf(y2)
tt<-seq(from=0, to=1, by=0.01)
plot(edf_beta2, verticals=TRUE, do.p=FALSE, main="ECDF and CDF: n=500")
lines(tt, pbeta(tt,3,4), col=2, lty=2, lwd=2)
qqplot(qbeta(ppoints(n),3,4),y,
main = expression("Q-Q plot for" ~~ {beta}(3,4)))
qqplot(qbeta(ppoints(n),3,4),y,
main = "Q-Q plot for Beta(3,4)"  )))
qqplot(qbeta(ppoints(n),3,4),y,
main = "Q-Q plot for Beta(3,4)"  ))
qqplot(qbeta(ppoints(n),3,4),y,
main = "Q-Q plot for Beta(3,4): n=50")
qqline(y, distribution = function(p) qbeta(p, 3,4),
prob = c(0, 1), col = 2)
install.packages("DAAG")
install.packages("DAAG")
install.packages("DAAG")
install.packages("DAAG")
install.packages("DAAG")
install.packages(DAAG)
install.packages("DAAG")
p=0.5; size1=10; size2=50
#normal approximation
x <- rnorm(size1, size1*p, sqrt(size1*p*(1-p)) )
pnorm(x, size1*p, sqrt(size1*p*(1-p)))
x <- rnorm(size1, size1*p, sqrt(size1*p*(1-p)) )
prob_norm <- pnorm(x, size1*p, sqrt(size1*p*(1-p)))
plot(x, prob_norm, type="h", main="n=10", xlab="x", ylab="f(x)", xlim=c(1,10),
cex.lab=1.5)
size1*p
x <- rnorm(size1, size1*p, sqrt(size1*p*(1-p)) )
prob_norm <- dnorm(x, size1*p, sqrt(size1*p*(1-p)))
plot(x, prob_norm, type="h", main="n=10", xlab="x", ylab="f(x)", xlim=c(1,10),
cex.lab=1.5)
help(dbinom)
x <- rnorm(size1, size1*p, sqrt(size1*p*(1-p)) )
prob_norm <- dnorm(x, size1*p, sqrt(size1*p*(1-p)))
prob_bin <- dbinom(x, size1,p)
plot(x, prob_bin, type="h", main="n=10", xlab="x", ylab="f(x)", xlim=c(1,10),
cex.lab=1.5, col="red")
curve(dnorm(x, size1*p, sqrt(size1*p*(1-p))), add=TRUE)
x <- rnorm(size1, size1*p, sqrt(size1*p*(1-p)) )
prob_norm <- dnorm(x, size1*p, sqrt(size1*p*(1-p)))
prob_bin <- dbinom(x, size1,p)
plot(x, prob_bin, type="h", main="n=10", xlab="x", ylab="f(x)", xlim=c(1,10),
cex.lab=1.5, col="red")
curve(dnorm(x, size1*p, sqrt(size1*p*(1-p))))
curve(dnorm(x, size1*p, sqrt(size1*p*(1-p))), xlim=c(1,10))
lines(prob_bin, type="h", main="n=10", xlab="x", ylab="f(x)", xlim=c(1,10),
cex.lab=1.5, col="red")
plot(prob_bin, type="h", main="n=10", xlab="x", ylab="f(x)", xlim=c(1,10),
cex.lab=1.5, col="red")
prob_bin <- dbinom(x, size1,p)
prob_bin
prob_bin <- dbinom(seq(0:10), size1,p)
prob_bin
x <- rnorm(size1, size1*p, sqrt(size1*p*(1-p)) )
#prob_norm <- dnorm(x, size1*p, sqrt(size1*p*(1-p)))
prob_bin <- dbinom(seq(0:10), size1,p)
curve(dnorm(x, size1*p, sqrt(size1*p*(1-p))), xlim=c(0,10))
lines(prob_bin, type="h", main="n=10", xlab="x", ylab="f(x)", xlim=c(1,10),
cex.lab=1.5, col="red")
x <- rnorm(size1, size1*p, sqrt(size1*p*(1-p)) )
prob_bin <- dbinom(seq(0:10), size1,p)
curve(dnorm(x, size1*p, sqrt(size1*p*(1-p))), xlim=c(0,10), xlab="x", ylab="f(x)")
lines(prob_bin, type="h", main="n=10", xlim=c(1,10),
cex.lab=1.5, col="red")
help(cars)
knitr::knit("Lab12.Rmd", tangle = TRUE, output ="foo.R") )
knitr::knit("Lab12.Rmd", tangle = TRUE, output ="foo.R")
library(knitr)
library(rmarkdown)
knitr::knit("Lab12.Rmd", tangle = TRUE, output ="foo.R")
Musicians <- c( "Selena Gomez",  "Ariana Grande", "Beyonce" , "Taylor Swift",  "Justin Bieber", "Nicki Minaj", "Nicola Gennaro", "Nilson", "Ginevra Carbone")
Others <- c("Cristiano Ronaldo", "Kim Kardashian",  "Kylie Jenner", "Dwayne Johnson", "Neymar", "Lionel Messi",
"Kendall Jenner", "Kourtney Kardashian", "Kevin Hart",)
n1 <- length(Musicians)
n2 <- length(Others)
Musicians <- c( "Selena Gomez",  "Ariana Grande", "Beyonce" , "Taylor Swift",  "Justin Bieber", "Nicki Minaj", "Nicola Gennaro", "Nilson", "Ginevra Carbone")
Others <- c("Cristiano Ronaldo", "Kim Kardashian",  "Kylie Jenner", "Dwayne Johnson", "Neymar", "Lionel Messi",
"Kendall Jenner", "Kourtney Kardashian", "Kevin Hart")
n1 <- length(Musicians)
n2 <- length(Others)
Followers_M<- c(135, 118, 113, 107,  98,  86, 1, 923*10^(-6) )
Followers_O <- c(123, 110, 106, 103,  91,  89,  89,  62,  58)
t <- t.test(Followers_M, Followers_O, mu = 0, alternative ="greater", var.equal =TRUE)
t
n <- 50
K <- 4
M <- 6
y <- matrix(0, M, n )
# generate the values
for (m in 1:M){
y[m, ] <- sample(1:K, n, replace=TRUE, prob = c( 7/16, 5/16, 3/16, 1/16) )
}
observed_matrix <- apply( y,1, table)
chisq.test(observed_matrix, p = c( 7/16, 5/16, 3/16, 1/16) )
n <- 50
K <- 4
M <- 6
y <- matrix(0, M+1, n )
# generate the values
for (m in 1:M){
y[m, ] <- sample(1:K, n, replace=TRUE, prob = c( 7/16, 5/16, 3/16, 1/16) )
}
y[7, ] <- sample(1:K, n, replace=TRUE, prob = c( 2/16, 3/16, 5/16, 6/16) )
observed_matrix <- apply( y,1, table)
chisq.test(observed_matrix, p = c( 7/16, 5/16, 3/16, 1/16) )
set.seed(1)
X <- 1:100
Y <- rnorm(length(X), 2*X + 10, 1)
N <- length(X)
model <- "
model {
for(i in 1 : N){ #data# N
Y[i] ~ dnorm(true.y[i], precision) #data# Y
true.y[i] <- (coef * X[i]) + int #data# X
}
coef ~ dunif(-1000,1000)
int ~ dunif(-1000,1000)
precision ~ dexp(1)
#inits# coef, int, precision
#monitor# coef, int, precision
}"
# A function to return initial values for each chain:
coef <- function(chain) return(switch(chain, "1"= -10, "2"= 10))
int <- function(chain) return(switch(chain, "1"= -10, "2"= 10))
precision <- function(chain) return(switch(chain, "1"= 0.01, "2"= 100))
init1 <- list(  coef=rnorm(1), int=rnorm(1), precision=runif(1))
init2 <- list(  coef=rnorm(1), int=rnorm(1), precision=runif(1))
# Run the simulation:
results <- run.jags(model, inits = list(init1, init2),  n.chains = 2)
library(runjags)
library(rjags)
set.seed(1)
X <- 1:100
Y <- rnorm(length(X), 2*X + 10, 1)
N <- length(X)
model <- "
model {
for(i in 1 : N){ #data# N
Y[i] ~ dnorm(true.y[i], precision) #data# Y
true.y[i] <- (coef * X[i]) + int #data# X
}
coef ~ dunif(-1000,1000)
int ~ dunif(-1000,1000)
precision ~ dexp(1)
#inits# coef, int, precision
#monitor# coef, int, precision
}"
# A function to return initial values for each chain:
coef <- function(chain) return(switch(chain, "1"= -10, "2"= 10))
int <- function(chain) return(switch(chain, "1"= -10, "2"= 10))
precision <- function(chain) return(switch(chain, "1"= 0.01, "2"= 100))
init1 <- list(  coef=rnorm(1), int=rnorm(1), precision=runif(1))
init2 <- list(  coef=rnorm(1), int=rnorm(1), precision=runif(1))
# Run the simulation:
results <- run.jags(model, inits = list(init1, init2),  n.chains = 2)
save(results, file="ris.RData", compress="xz")
log_lik_weibull <- function( data, param){
-sum(dweibull(data, shape = param[1], scale = param[2], log = TRUE))
}
y <- c(155.9, 200.2, 143.8, 150.1,152.1, 142.2, 147, 146, 146, 170.3, 148, 140, 118, 144, 97)
theta <- function(omega) exp(omega)
log_lik_weibull_rep <- function(data, param) log_lik_weibull(data, theta(param))
weib.y.nlm<-suppressWarnings(nlm(log_lik_weibull_rep,c(0,0),hessian=T,data=y))
varOmega<-diag(solve(weib.y.nlm$hessian))
print("Variance for the estimator omega:")
weib.y.nlm
exp(weib.y.nlm$estimate)
help("norm")
dt_ls(x, df, mu, sigma) =
1/sigma * dt((x - mu)/sigma, df)
dpois_ls(x, df, mu, sigma) =
dpois((x - mu))
dpois_ls(x,  mu) =function(x){
dpois((x - mu))}
dpois_ls =function(x, mu){
dpois((x - mu))}
dpois_ls(2,4)
dpois_ls =function(x, mu){
dpois((x - mu))}
245*1.14
280/6
171+144
171/6
library(rstanarm)
help("stan_glmer")
740/16
setwd("~/GitHub/pivmet")
library(devtools)
install_github("pivmet/leoegidi")
install_github("leoegidi/pivmet")
install_github("LeoEgidi/pivmet")
library(effects)
install_github("LeoEgidi/pivmet")
install_github("LeoEgidi/pivmet")
install_github("LeoEgidi/pivmet")
help("install_github")
install_github("r-lib/devtools")
install_github("LeoEgidi/pivmet")
install_github("LeoEgidi/pivmet")
install_github("hadley/pryr")
install_github("LeoEgidi/pivmet")
install_github("LeoEgidi/pivmet")
install_github("LeoEgidi/pivmet", dependencies=TRUE, force =TRUE)
Depends: MASS,
runjags,
rjags,
cluster,
mclust,
rmarkdown,
bayesmix,
Rcmdr,
mvtnorm
install_github("LeoEgidi/pivmet", dependencies=TRUE, force =TRUE)
install.packages("githubinstall")
install.packages("githubinstall")
library(githubinstall)
library("githubinstall")
githubinstall("pivmet")
install_github("LeoEgidi/pivmet", dependencies=TRUE, force =TRUE)
livrary(devtools)
library(devtools)
install.packages("devtools")
library(devtools)
library(devtools)
install_github("leoegidi/pivmet")
devtools::find_rtools(TRUE)
install_github("leoegidi/pivmet")
install_github("leoegidi/pivmet")
install_github("leoegidi/pivmet")
library(MASS)
remove.packages("MASS", lib="C:/Program Files/R/R-3.4.1/library")
remove.packages("MASS", lib="C:/Program Files/R/R-3.4.1/library")
library("cluster", lib.loc="~/R/win-library/3.4")
library("mclust", lib.loc="~/R/win-library/3.4")
remove.packages("cluster", lib="~/R/win-library/3.4")
library("mclust", lib.loc="~/R/win-library/3.4")
remove.packages("mclust", lib="~/R/win-library/3.4")
library("bayesmix", lib.loc="~/R/win-library/3.4")
remove.packages("bayesmix", lib="~/R/win-library/3.4")
library("Rcmdr", lib.loc="~/R/win-library/3.4")
remove.packages("Rcmdr", lib="~/R/win-library/3.4")
remove.packages("mvtnorm", lib="~/R/win-library/3.4")
remove.packages("testthat", lib="~/R/win-library/3.4")
remove.packages("rmarkdown", lib="~/R/win-library/3.4")
remove.packages("runjags", lib="~/R/win-library/3.4")
remove.packages("rjags", lib="~/R/win-library/3.4")
install_github("leoegidi/pivmet")
install_github("leoegidi/pivmet")
install.packages("rjags")
install.packages("rjags")
library(rjags)
install_github("leoegidi/pivmet")
library(devtools)
install_github("leoegidi/pivmet")
install_github("leoegidi/pivmet")
install.packages("mvtnorm")
install.packages("mclust")
install_github("leoegidi/pivmet")
install_github("leoegidi/pivmet")
install_github("leoegidi/pivmet")
install.packages("mclust")
.libPaths()
library(mclust)
install.packages("mclust")
