names(list(a=2))
names(list(a=2, b=3))
c("a", "b", "c")[names(list(a=2, b=3))]
match(c("a", "b", "c"), names(list(a=2, b=3)))
match(c("a", "b", "c"), names(list(a=2, b=3)), na.rm =TRUE)
match(c("a", "b", "c"), names(list(a=2, b=3)))
match(c("a", "b", "c"), names(list(a=2, c=3)))
which(  c("a", "b", "c"), names(list(a=2, c=3)) )
which(  c("a", "b", "c")==names(list(a=2, c=3)) )
which(c("a", "b", "c"))
which(c("a", "b", "c"), names(list(a=1, b=2)))
help("which")
intersect(c("a", "b", "c"), names(list(a=1, b=2)))
true.opt<-intersect(c("a", "b", "c"), names(list(a=1, b=2)))
true.opt
true.opt[1]
c(iter.max, num.seeds)
true.opt
list(a=1, b=2)
list(a=2)
list(...)
...=list(a=2, b=1)
...
list(a=2, b=1)
eval(list(a=2, b=1))
eval(list(a=2, b=1))[1]
eval(list(a=2, b=1, c=3))[1]
eval(list(a=2, b=1, c=3))
list(a=2, b=1, c=3)
list(a=2, b=1, c=3)$a
list(a=2, b=1, c=3)$c(a, b)
d<-c(a,b)
list(a=2, b=1, c=3)$d
list(a=2, b=1, c=3)$d[1]
list(a=2, b=1, c=3)$a
list(a=2, b=1, c=3)$a
list(a=2, b=1, c=3)$b
list(a=2, b=1, c=3)$as.character(d[1])
list(a=2, b=1, c=3)$eval(d[1])
d[1]
d
d<-c("a", "b")
list(a=2, b=1, c=3)$d[1]
d
list(a=2, b=1, c=3)$eval(d[1])
d
as.expression)d[1]
as.expression(d[1])
list(a=2, b=1, c=3)$as.expression(d[1])
list(a=2, b=1, c=3)$as.character(d[1])
d[1]
as.double(d[1])
as.symbol(d[1])
list(a=2, b=1, c=3)$as.symbol(d[1])
as.symbol(d[1])
list(a=2, b=1, c=3)$as.symbol(d[1])
names(list(a=2, b=1))
list(a=2, b=1, c=3)$iter.max
is.null(list(a=1, b=2)$a)
which(is.null(c(list(a=1)$a, list(a=1)$b)))
is.null(c(list(a=1)$a, list(a=1)$b))
is.null(c(list(a=1)$a, list(a=1)$b))
c(is.null((list(a=1)$a), is.null( list(a=1)$b)))
c(is.null((list(a=1)$a), is.null( list(a=1)$b)))
is.null((list(a=1)$a)
)
c(is.null(list(a=1)$a), is.null( list(a=1)$b)))
c(is.null(list(a=1)$a), is.null( list(a=1)$b))
which(c(is.null(list(a=1)$a), is.null( list(a=1)$b)))
which(c(is.null(list(a=1)$a), is.null( list(a=1)$b)))
piv_KMeans <- function(x,
centers,
alg.type = c("KMeans", "hclust"),
piv.criterion = c("MUS", "maxsumint", "minsumnoint", "maxsumdiff"),
H = 1000,
...){
#check on optional parameters
if(missing(...)){
iter.max  <- 10
num.seeds <- 10
prec.par  <- 5
}else{
if(is.null(list(...)$iter.max)==FALSE){
iter.max <- list(...)$iter.max
}
if(is.null(list(...)$num.seeds)==FALSE){
num.seeds <- list(...)$num.seeds
}
if(is.null(list(...)$prec.par)==FALSE){
prec.par <- list(...)$prec.par
}
}
if (missing(piv.criterion)){
if (centers<=4 ){
piv.criterion <- "MUS"
}else{
piv.criterion <- "maxsumdiff"
}
}
if (missing(H)){
H <- 1000
}
if (missing(alg.type)){
alg.type <- "KMeans"
}
#type of clustering for initial clusters' assignment
if (alg.type=="hclust"){
cl <-cutree(hclust(dist(x), "average"),centers)
}else if (alg.type=="KMeans"){
cl <- KMeans(x,centers)$cluster
}
# tuning of precision MUS parameter
# if (missing(prec.par)){
#   prec.par <- min( min(table(cl))-1, 5 )
# }
#compute H different partitions
if (is.vector(x)){
n <- length(x)
}else{
n <- dim(x)[1]
}
a <- matrix(NA, H, n)
for (h in 1:H){
a[h,] <- kmeans(x,centers)$cluster
}
sim_matr <- matrix(1, n,n)
for (i in 1:(n-1)){
for (j in (i+1):n){
sim_matr[i,j] <- sum(a[,i]==a[,j])/H
sim_matr[j,i] <- sim_matr[i,j]
}
}
if (centers <=4){
if (piv.criterion=="MUS"){
#MUS algorithm
#prec.par <- prec.par
mus_res  <- MUS(sim_matr, cl)
pivots   <- mus_res$pivots
}else if (piv.criterion!="MUS"){
#Other pivotal criteria
z <- array(0,dim=c(n, centers, H))
for (i in 1:H){
for (j in 1:n){
z[j,a[i,j],i] <- 1
}
}
zm <- apply(z,c(1,3),FUN=function(x) sum(x*(1:length(x))))
sel <- piv_sel(C=sim_matr, clusters=cl)
if (piv.criterion=="maxsumint"){
pivots <- sel$pivots[,1]
}else if(piv.criterion=="minsumnoint"){
pivots <- sel$pivots[,2]
}else if(piv.criterion=="maxsumdiff"){
pivots <- sel$pivots[,3]
}
}
}else{
z <- array(0,dim=c(n, centers, H))
for (i in 1:H){
for (j in 1:n){
z[j,a[i,j],i] <- 1
}
}
zm <- apply(z,c(1,3),FUN=function(x) sum(x*(1:length(x))))
sel <- piv_sel(C=sim_matr,  clusters=cl)
if (piv.criterion=="maxsumint"){
pivots <- sel$pivots[,1]
}else if(piv.criterion=="minsumnoint"){
pivots <- sel$pivots[,2]
}else if(piv.criterion=="maxsumdiff"){
pivots <- sel$pivots[,3]
}
}
#Initial seeding
if(is.vector(x)){
dim_x <- 1
start <- c()
for (k in 1:centers){
start[k] <- as.double(x[pivots[k]])
}
}else if(is.matrix(x)){
dim_x <- dim(x)[2]
start <- matrix(NA, centers, dim_x )
for (k in 1:centers){
start[k,] <- as.double(x[pivots[k],])
}
}
#MUSKmeans
d_mus   <- KMeans(x, centers=start, iter.max = iter.max,
num.seeds = num.seeds)
return(list(cluster=d_mus$cluster,
centers=d_mus$centers,
totss=d_mus$totss,
withinss=d_mus$withinss,
tot.withinss=d_mus$tot.withinss,
betweenss=d_mus$betweenss,
size=d_mus$size,
iter=d_mus$iter,
ifaults=d_mus$ifault,
pivots = pivots,
piv.criterion = piv.criterion))
}
piv_KMeans(rnorm(20), k=3, iter.max=12)
piv_KMeans(rnorm(20), centers = 3, iter.max=12)
piv_KMeans(rnorm(20), centers = 3, piv.criterion = "minsumnoint", iter.max=12)
piv_KMeans(rnorm(50), centers = 3, piv.criterion = "minsumnoint", iter.max=12)
which(c(is.null(list(a=1)$a), is.null( list(a=1)$b)))
piv_KMeans <- function(x,
centers,
alg.type = c("KMeans", "hclust"),
piv.criterion = c("MUS", "maxsumint", "minsumnoint", "maxsumdiff"),
H = 1000,
...){
#check on optional parameters
if(missing(...)){
iter.max  <- 10
num.seeds <- 10
prec.par  <- 5
}else{
iter.max  <-  c(10, list(...)$iter.max)[which(c(is.null(list(...)$iter.max), !is.null(list(...)$iter.max)))]
num.seeds <-  c(10, list(...)$num.seeds)[which(c(is.null(list(...)$num.seeds), !is.null(list(...)$num.seeds)))]
prec.par  <-  c(5, list(...)$prec.par)[which(c(is.null(list(...)$prec.par), !is.null(list(...)$prec.par)))]
}
if (missing(piv.criterion)){
if (centers<=4 ){
piv.criterion <- "MUS"
}else{
piv.criterion <- "maxsumdiff"
}
}
if (missing(H)){
H <- 1000
}
if (missing(alg.type)){
alg.type <- "KMeans"
}
#type of clustering for initial clusters' assignment
if (alg.type=="hclust"){
cl <-cutree(hclust(dist(x), "average"),centers)
}else if (alg.type=="KMeans"){
cl <- KMeans(x,centers)$cluster
}
# tuning of precision MUS parameter
# if (missing(prec.par)){
#   prec.par <- min( min(table(cl))-1, 5 )
# }
#compute H different partitions
if (is.vector(x)){
n <- length(x)
}else{
n <- dim(x)[1]
}
a <- matrix(NA, H, n)
for (h in 1:H){
a[h,] <- kmeans(x,centers)$cluster
}
sim_matr <- matrix(1, n,n)
for (i in 1:(n-1)){
for (j in (i+1):n){
sim_matr[i,j] <- sum(a[,i]==a[,j])/H
sim_matr[j,i] <- sim_matr[i,j]
}
}
if (centers <=4){
if (piv.criterion=="MUS"){
#MUS algorithm
#prec.par <- prec.par
mus_res  <- MUS(sim_matr, cl)
pivots   <- mus_res$pivots
}else if (piv.criterion!="MUS"){
#Other pivotal criteria
z <- array(0,dim=c(n, centers, H))
for (i in 1:H){
for (j in 1:n){
z[j,a[i,j],i] <- 1
}
}
zm <- apply(z,c(1,3),FUN=function(x) sum(x*(1:length(x))))
sel <- piv_sel(C=sim_matr, clusters=cl)
if (piv.criterion=="maxsumint"){
pivots <- sel$pivots[,1]
}else if(piv.criterion=="minsumnoint"){
pivots <- sel$pivots[,2]
}else if(piv.criterion=="maxsumdiff"){
pivots <- sel$pivots[,3]
}
}
}else{
z <- array(0,dim=c(n, centers, H))
for (i in 1:H){
for (j in 1:n){
z[j,a[i,j],i] <- 1
}
}
zm <- apply(z,c(1,3),FUN=function(x) sum(x*(1:length(x))))
sel <- piv_sel(C=sim_matr,  clusters=cl)
if (piv.criterion=="maxsumint"){
pivots <- sel$pivots[,1]
}else if(piv.criterion=="minsumnoint"){
pivots <- sel$pivots[,2]
}else if(piv.criterion=="maxsumdiff"){
pivots <- sel$pivots[,3]
}
}
#Initial seeding
if(is.vector(x)){
dim_x <- 1
start <- c()
for (k in 1:centers){
start[k] <- as.double(x[pivots[k]])
}
}else if(is.matrix(x)){
dim_x <- dim(x)[2]
start <- matrix(NA, centers, dim_x )
for (k in 1:centers){
start[k,] <- as.double(x[pivots[k],])
}
}
#MUSKmeans
d_mus   <- KMeans(x, centers=start, iter.max = iter.max,
num.seeds = num.seeds)
return(list(cluster=d_mus$cluster,
centers=d_mus$centers,
totss=d_mus$totss,
withinss=d_mus$withinss,
tot.withinss=d_mus$tot.withinss,
betweenss=d_mus$betweenss,
size=d_mus$size,
iter=d_mus$iter,
ifaults=d_mus$ifault,
pivots = pivots,
piv.criterion = piv.criterion))
}
piv_KMeans(rnorm(50), centers = 3, piv.criterion = "minsumnoint", list(iter.max=12))
piv_KMeans(rnorm(50), centers = 3, piv.criterion = "minsumnoint")
piv_KMeans <- function(x,
centers,
alg.type = c("KMeans", "hclust"),
piv.criterion = c("MUS", "maxsumint", "minsumnoint", "maxsumdiff"),
H = 1000,
opt = list(iter.max =10, num.seeds =10, prec.par =5)){
#check on optional parameters
if(missing(opt)){
iter.max  <- 10
num.seeds <- 10
prec.par  <- 5
}else{
iter.max  <-  c(10, list(opt)$iter.max)[which(c(is.null(list(opt)$iter.max), !is.null(list(opt)$iter.max)))]
num.seeds <-  c(10, list(opt)$num.seeds)[which(c(is.null(list(opt)$num.seeds), !is.null(list(opt)$num.seeds)))]
prec.par  <-  c(5, list(opt)$prec.par)[which(c(is.null(list(opt)$prec.par), !is.null(list(opt)$prec.par)))]
}
if (missing(piv.criterion)){
if (centers<=4 ){
piv.criterion <- "MUS"
}else{
piv.criterion <- "maxsumdiff"
}
}
if (missing(H)){
H <- 1000
}
if (missing(alg.type)){
alg.type <- "KMeans"
}
#type of clustering for initial clusters' assignment
if (alg.type=="hclust"){
cl <-cutree(hclust(dist(x), "average"),centers)
}else if (alg.type=="KMeans"){
cl <- KMeans(x,centers)$cluster
}
# tuning of precision MUS parameter
# if (missing(prec.par)){
#   prec.par <- min( min(table(cl))-1, 5 )
# }
#compute H different partitions
if (is.vector(x)){
n <- length(x)
}else{
n <- dim(x)[1]
}
a <- matrix(NA, H, n)
for (h in 1:H){
a[h,] <- kmeans(x,centers)$cluster
}
sim_matr <- matrix(1, n,n)
for (i in 1:(n-1)){
for (j in (i+1):n){
sim_matr[i,j] <- sum(a[,i]==a[,j])/H
sim_matr[j,i] <- sim_matr[i,j]
}
}
if (centers <=4){
if (piv.criterion=="MUS"){
#MUS algorithm
#prec.par <- prec.par
mus_res  <- MUS(sim_matr, cl)
pivots   <- mus_res$pivots
}else if (piv.criterion!="MUS"){
#Other pivotal criteria
z <- array(0,dim=c(n, centers, H))
for (i in 1:H){
for (j in 1:n){
z[j,a[i,j],i] <- 1
}
}
zm <- apply(z,c(1,3),FUN=function(x) sum(x*(1:length(x))))
sel <- piv_sel(C=sim_matr, clusters=cl)
if (piv.criterion=="maxsumint"){
pivots <- sel$pivots[,1]
}else if(piv.criterion=="minsumnoint"){
pivots <- sel$pivots[,2]
}else if(piv.criterion=="maxsumdiff"){
pivots <- sel$pivots[,3]
}
}
}else{
z <- array(0,dim=c(n, centers, H))
for (i in 1:H){
for (j in 1:n){
z[j,a[i,j],i] <- 1
}
}
zm <- apply(z,c(1,3),FUN=function(x) sum(x*(1:length(x))))
sel <- piv_sel(C=sim_matr,  clusters=cl)
if (piv.criterion=="maxsumint"){
pivots <- sel$pivots[,1]
}else if(piv.criterion=="minsumnoint"){
pivots <- sel$pivots[,2]
}else if(piv.criterion=="maxsumdiff"){
pivots <- sel$pivots[,3]
}
}
#Initial seeding
if(is.vector(x)){
dim_x <- 1
start <- c()
for (k in 1:centers){
start[k] <- as.double(x[pivots[k]])
}
}else if(is.matrix(x)){
dim_x <- dim(x)[2]
start <- matrix(NA, centers, dim_x )
for (k in 1:centers){
start[k,] <- as.double(x[pivots[k],])
}
}
#MUSKmeans
d_mus   <- KMeans(x, centers=start, iter.max = iter.max,
num.seeds = num.seeds)
return(list(cluster=d_mus$cluster,
centers=d_mus$centers,
totss=d_mus$totss,
withinss=d_mus$withinss,
tot.withinss=d_mus$tot.withinss,
betweenss=d_mus$betweenss,
size=d_mus$size,
iter=d_mus$iter,
ifaults=d_mus$ifault,
pivots = pivots,
piv.criterion = piv.criterion))
}
piv_KMeans(rnorm(50), centers = 3, piv.criterion = "minsumnoint", opt=list(iter.max=12))
piv_KMeans(rnorm(50), centers = 3, piv.criterion = "minsumnoint", opt=list(iter.max=12, num.seeds=4))
piv_KMeans(rnorm(50), centers = 3, piv.criterion = "minsumnoint", opt=list(iter.max=12, num.seeds=4, prec.par=4))
piv_KMeans(rnorm(50), centers = 3, piv.criterion = "minsumnoint")
piv_KMeans(rnorm(50), centers = 3)
devtools::document()
library(pivmet)
N  <- 620
k  <- 3
n1 <- 20
n2 <- 100
n3 <- 500
x  <- matrix(NA, N,2)
truegroup <- c( rep(1,n1), rep(2, n2), rep(3, n3))
for (i in 1:n1){
x[i,]=rmvnorm(1, c(1,5), sigma=diag(2))}
for (i in 1:n2){
x[n1+i,]=rmvnorm(1, c(4,0), sigma=diag(2))}
for (i in 1:n3){
x[n1+n2+i,]=rmvnorm(1, c(6,6), sigma=diag(2))}
# Apply piv_KMeans with MUS as pivotal criterion
res <- piv_KMeans(x, k)
# Apply piv_KMeans with maxsumdiff as pivotal criterion
res2 <- piv_KMeans(x, k, piv.criterion ="maxsumdiff")
res2 <- piv_KMeans(x, k, piv.criterion ="maxsumdiff", opt=list(num.seeds=15))
res2 <- piv_KMeans(x, k, piv.criterion ="maxsumdiff", opt=list(prec.par=6))
data(fish)
y <- fish[,1]
k <- 5
nMC <- 5000
res <- piv_MCMC(y = y, k = k, nMC = nMC)
data(fish)
y <- fish[,1]
k <- 5
nMC <- 5000
res <- piv_MCMC(y = y, k = k, nMC = nMC, clustering ="diana")
res
res$Mu
res$mu_switch
devtools::document()
library(pivmet)
x<- rt(100)
x<- rt(100,4)
piv_Kmeans(x, 2)
piv_KMeans(x, 2)
piv_KMeans(x, 2, piv.criterion = "maxsumdiff")
piv_KMeans(x, 2)
devtools::build_win()
devtools
devtools::document()
library(pivmet)
