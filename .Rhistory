log_sum_exp(normal_lpdf(y[n]|mu, sigma)+
log_theta);
exp_pz[n] = exp(pz[n]);
}
}
model {
sigma ~ lognormal(mu_phi, sigma_phi);
mu ~ normal(mu_0, 1/B0inv);
for (n in 1:N) {
vector[k] lps = log_theta;
for (j in 1:k){
lps[j] += normal_lpdf(y[n] | mu[j], sigma[j]);
target+=pz[n,j];
}
target += log_sum_exp(lps);
}
}
generated quantities{
matrix[N,k] log_lik;
int<lower=1, upper=k> z[N];
for (n in 1:N){
z[n] = categorical_rng(exp_pz[n]);
}
for (n in 1:N){
for (j in 1:k){
log_lik[n,j] =  normal_lpdf(y[n] | mu[j], sigma[j])+log_theta[j];
}
}
}
"
k_vec <- c(1:k_max)
for (h in 2:k){
data = list(N=N, y=y, k=k_vec[h],
mu_0=mu_0, B0inv=B0inv,
mu_phi=mu_phi, sigma_phi=sigma_phi)
fit_univ <-  stan(model_code = mix_univ,
data=data,
chains =chains,
iter =nMC)
}
h
data = list(N=N, y=y, k=k_vec[h],
mu_0=mu_0, B0inv=B0inv,
mu_phi=mu_phi, sigma_phi=sigma_phi)
fit_univ <-  stan(model_code = mix_univ,
data=data,
chains =chains,
iter =nMC)
library(loo)
log_lik <- extract_log_lik(fit_univ)
loo <- loo(log_lik)
loo
loo$looic
loo$estimates
loo$estimates[3,1]
k_vec <- c(1:k_max)
LOOIC <- c()
for (h in 2:k){
data <- list(N=N, y=y, k=k_vec[h],
mu_0=mu_0, B0inv=B0inv,
mu_phi=mu_phi, sigma_phi=sigma_phi)
fit_univ <-  stan(model_code = mix_univ,
data=data,
chains =chains,
iter =nMC)
log_lik <- extract_log_lik(fit_univ)
loo <- loo(log_lik)
LOOIC[h-1] <- loo$estimates[3,1]
}
LOOIC
k_vec <- c(1:k_max)
LOOIC <- c()
for (h in 2:k_max){
data <- list(N=N, y=y, k=k_vec[h],
mu_0=mu_0, B0inv=B0inv,
mu_phi=mu_phi, sigma_phi=sigma_phi)
fit_univ <-  stan(model_code = mix_univ,
data=data,
chains =chains,
iter =nMC)
log_lik <- extract_log_lik(fit_univ)
loo <- loo(log_lik)
LOOIC[h-1] <- loo$estimates[3,1]
}
LOOIC
k
data(galaxies)
y<-galaxies/1000
nMC
k_vec <- c(1:k_max)
LOOIC <- c()
y
k_vec <- c(1:k_max)
LOOIC <- c()
for (h in 2:k_max){
data <- list(N=N, y=y, k=k_vec[h],
mu_0=mu_0, B0inv=B0inv,
mu_phi=mu_phi, sigma_phi=sigma_phi)
fit_univ <-  stan(model_code = mix_univ,
data=data,
chains =chains,
iter =nMC)
log_lik <- extract_log_lik(fit_univ)
loo <- loo(log_lik)
LOOIC[h-1] <- loo$estimates[3,1]
}
LOOIC
hrlp(loo)
help(loo)
help("extract_log_lik")
dim(log_lik)
N
k
k_max
mix_univ <-"
data {
int<lower=1> k;          // number of mixture components
int<lower=1> N;          // number of data points
real y[N];               // observations
real mu_0;               // mean hyperparameter
real<lower=0> B0inv;     // mean hyperprecision
real mu_phi;             // sigma hypermean
real<lower=0> sigma_phi; // sigma hyper sd
}
parameters {
simplex[k] theta;        // mixing proportions
ordered[k] mu;              // locations of mixture components
vector<lower=0>[k] sigma;   // scales of mixture components
}
transformed parameters{
vector[k] log_theta = log(theta);  // cache log calculation
vector[k] pz[N];
simplex[k] exp_pz[N];
for (n in 1:N){
pz[n] =   normal_lpdf(y[n]|mu, sigma)+
log_theta-
log_sum_exp(normal_lpdf(y[n]|mu, sigma)+
log_theta);
exp_pz[n] = exp(pz[n]);
}
}
model {
sigma ~ lognormal(mu_phi, sigma_phi);
mu ~ normal(mu_0, 1/B0inv);
for (n in 1:N) {
vector[k] lps = log_theta;
for (j in 1:k){
lps[j] += normal_lpdf(y[n] | mu[j], sigma[j]);
target+=pz[n,j];
}
target += log_sum_exp(lps);
}
}
generated quantities{
matrix[N,k] ll;
vector[N] log_lik;
int<lower=1, upper=k> z[N];
for (n in 1:N){
z[n] = categorical_rng(exp_pz[n]);
}
for (n in 1:N){
for (j in 1:k){
ll[n,j] = normal_lpdf(y[n] | mu[j], sigma[j])+log_theta[j];
}
log_lik[n] <- log_sum_exp(ll[n,])
}
}
"
data <- list(N=N, y=y, k=k_vec[h],
mu_0=mu_0, B0inv=B0inv,
mu_phi=mu_phi, sigma_phi=sigma_phi)
fit_univ <-  stan(model_code = mix_univ,
data=data,
chains =chains,
iter =nMC)
mix_univ <-"
data {
int<lower=1> k;          // number of mixture components
int<lower=1> N;          // number of data points
real y[N];               // observations
real mu_0;               // mean hyperparameter
real<lower=0> B0inv;     // mean hyperprecision
real mu_phi;             // sigma hypermean
real<lower=0> sigma_phi; // sigma hyper sd
}
parameters {
simplex[k] theta;        // mixing proportions
ordered[k] mu;              // locations of mixture components
vector<lower=0>[k] sigma;   // scales of mixture components
}
transformed parameters{
vector[k] log_theta = log(theta);  // cache log calculation
vector[k] pz[N];
simplex[k] exp_pz[N];
for (n in 1:N){
pz[n] =   normal_lpdf(y[n]|mu, sigma)+
log_theta-
log_sum_exp(normal_lpdf(y[n]|mu, sigma)+
log_theta);
exp_pz[n] = exp(pz[n]);
}
}
model {
sigma ~ lognormal(mu_phi, sigma_phi);
mu ~ normal(mu_0, 1/B0inv);
for (n in 1:N) {
vector[k] lps = log_theta;
for (j in 1:k){
lps[j] += normal_lpdf(y[n] | mu[j], sigma[j]);
target+=pz[n,j];
}
target += log_sum_exp(lps);
}
}
generated quantities{
matrix[N,k] ll;
vector[N] log_lik;
int<lower=1, upper=k> z[N];
for (n in 1:N){
z[n] = categorical_rng(exp_pz[n]);
}
for (n in 1:N){
for (j in 1:k){
ll[n,j] = normal_lpdf(y[n] | mu[j], sigma[j])+log_theta[j];
}
log_lik[n] <- log_sum_exp(ll[n,]);
}
}
"
k_vec <- c(1:k_max)
LOOIC <- c()
data <- list(N=N, y=y, k=k_vec[h],
mu_0=mu_0, B0inv=B0inv,
mu_phi=mu_phi, sigma_phi=sigma_phi)
fit_univ <-  stan(model_code = mix_univ,
data=data,
chains =chains,
iter =nMC)
mix_univ <-"
data {
int<lower=1> k;          // number of mixture components
int<lower=1> N;          // number of data points
real y[N];               // observations
real mu_0;               // mean hyperparameter
real<lower=0> B0inv;     // mean hyperprecision
real mu_phi;             // sigma hypermean
real<lower=0> sigma_phi; // sigma hyper sd
}
parameters {
simplex[k] theta;        // mixing proportions
ordered[k] mu;              // locations of mixture components
vector<lower=0>[k] sigma;   // scales of mixture components
}
transformed parameters{
vector[k] log_theta = log(theta);  // cache log calculation
vector[k] pz[N];
simplex[k] exp_pz[N];
for (n in 1:N){
pz[n] =   normal_lpdf(y[n]|mu, sigma)+
log_theta-
log_sum_exp(normal_lpdf(y[n]|mu, sigma)+
log_theta);
exp_pz[n] = exp(pz[n]);
}
}
model {
sigma ~ lognormal(mu_phi, sigma_phi);
mu ~ normal(mu_0, 1/B0inv);
for (n in 1:N) {
vector[k] lps = log_theta;
for (j in 1:k){
lps[j] += normal_lpdf(y[n] | mu[j], sigma[j]);
target+=pz[n,j];
}
target += log_sum_exp(lps);
}
}
generated quantities{
matrix[N,k] ll;
vector[N] log_lik;
int<lower=1, upper=k> z[N];
for (n in 1:N){
z[n] = categorical_rng(exp_pz[n]);
}
for (n in 1:N){
for (j in 1:k){
ll[n,j] = normal_lpdf(y[n] | mu[j], sigma[j])+log_theta[j];
}
log_lik[n] = log_sum_exp(ll[n,]);
}
}
"
LOOIC <- c()
LOOIC
data <- list(N=N, y=y, k=k_vec[h],
mu_0=mu_0, B0inv=B0inv,
mu_phi=mu_phi, sigma_phi=sigma_phi)
fit_univ <-  stan(model_code = mix_univ,
data=data,
chains =chains,
iter =nMC)
LOOIC <- c()
LOOIC
galaxies
y
hist(y)
hist(y, breaks=40)
y<-galaxies
y<-galaxies/1000
hist(y)
hist(y, breaks=40, prob = TRUE, cex.lab=1.6,
main ="Galaxies data", cex.main =1.7,
col="navajowhite1", border="navajowhite1")
y <- galaxies
y <- y/1000
hist(y, breaks=40, prob = TRUE, cex.lab=1.6,
main ="Galaxies data", cex.main =1.7,
col="navajowhite1", border="navajowhite1")
data(galaxies)
y <- galaxies
y <- y/1000
hist(y, breaks=40, prob = TRUE, cex.lab=1.6,
main ="Galaxies data", cex.main =1.7,
col="navajowhite1", border="navajowhite1")
data(galaxies)
y <- galaxies
y <- y/1000
y
galaxies
data(galaxies)
galaxies
y<-fish[,1]
y
library(MASS)
data(galaxies)
y<-galaxies/1000
hist/y
hist(y)
mu_0 <- 0
B0inv <- 0.1
mu_phi <- 0
sigma_phi <- 2
mix_univ <-"
data {
int<lower=1> k;          // number of mixture components
int<lower=1> N;          // number of data points
real y[N];               // observations
real mu_0;               // mean hyperparameter
real<lower=0> B0inv;     // mean hyperprecision
real mu_phi;             // sigma hypermean
real<lower=0> sigma_phi; // sigma hyper sd
}
parameters {
simplex[k] theta;        // mixing proportions
ordered[k] mu;              // locations of mixture components
vector<lower=0>[k] sigma;   // scales of mixture components
}
transformed parameters{
vector[k] log_theta = log(theta);  // cache log calculation
vector[k] pz[N];
simplex[k] exp_pz[N];
for (n in 1:N){
pz[n] =   normal_lpdf(y[n]|mu, sigma)+
log_theta-
log_sum_exp(normal_lpdf(y[n]|mu, sigma)+
log_theta);
exp_pz[n] = exp(pz[n]);
}
}
model {
sigma ~ lognormal(mu_phi, sigma_phi);
mu ~ normal(mu_0, 1/B0inv);
for (n in 1:N) {
vector[k] lps = log_theta;
for (j in 1:k){
lps[j] += normal_lpdf(y[n] | mu[j], sigma[j]);
target+=pz[n,j];
}
target += log_sum_exp(lps);
}
}
generated quantities{
matrix[N,k] ll;
vector[N] log_lik;
int<lower=1, upper=k> z[N];
for (n in 1:N){
z[n] = categorical_rng(exp_pz[n]);
}
for (n in 1:N){
for (j in 1:k){
ll[n,j] = normal_lpdf(y[n] | mu[j], sigma[j])+log_theta[j];
}
log_lik[n] = log_sum_exp(ll[n,]);
}
}
"
nMC=500
chains=3
k_vec <- c(1:k_max)
LOOIC <- c()
k_max=8
k_vec <- c(1:k_max)
LOOIC <- c()
library(loo)
library(rstan)
N<-length(y)
y
k_vec <- c(1:k_max)
LOOIC <- c()
for (h in 5:k_max){
data <- list(N=N, y=y, k=k_vec[h],
mu_0=mu_0, B0inv=B0inv,
mu_phi=mu_phi, sigma_phi=sigma_phi)
fit_univ <-  stan(model_code = mix_univ,
data=data,
chains =chains,
iter =nMC)
log_lik <- extract_log_lik(fit_univ)
loo <- loo(log_lik)
LOOIC[h-1] <- loo$estimates[3,1]
}
y<-fish[,1]
N <- length(y)
k_vec <- c(1:k_max)
k_max
DIC <- c()
mod.mist.univ  <- "model {
# Likelihood:
for( i in 1 : N ) {
y[i] ~ dnorm( mu[i] , tau[i] )
mu[i] <- muOfClust[ clust[i] ]
tau[i] <- tauOfClust[ clust[i]]
clust[i] ~ dcat( pClust[1:k] )
}
# Prior:
for ( g in 1: k ) {
tauOfClust[g] ~ dgamma( 0.01 , 0.01 )
muOfClust[g] ~ dnorm( mu_0 , 1.0E-10 )
}
pClust[1:Nclust] ~ ddirch( alpha )
}
"
mod.mist.univ  <- "model {
# Likelihood:
for( i in 1 : N ) {
y[i] ~ dnorm( mu[i] , tau[i] )
mu[i] <- muOfClust[ clust[i] ]
tau[i] <- tauOfClust[ clust[i]]
clust[i] ~ dcat( pClust[1:k] )
}
# Prior:
for ( g in 1: k ) {
tauOfClust[g] ~ dgamma( 0.01 , 0.01 )
muOfClust[g] ~ dnorm( mu_0 , 1.0E-10 )
}
pClust[1:k] ~ ddirch( alpha )
}
"
k_vec <- c(1:k_max)
DIC <- c()
mod.mist.univ  <- "model {
# Likelihood:
for( i in 1 : N ) {
y[i] ~ dnorm( mu[i] , tau[i] )
mu[i] <- muOfClust[ clust[i] ]
tau[i] <- tauOfClust[ clust[i]]
clust[i] ~ dcat( pClust[1:k] )
}
# Prior:
for ( g in 1: k ) {
tauOfClust[g] ~ dgamma( 0.01 , 0.01 )
muOfClust[g] ~ dnorm( mu_0 , 1.0E-10 )
}
pClust[1:k] ~ ddirch( alpha )
}
"
h=2
mu_0 <- 0
alpha <- rep(1,k_vec[h])
dati.univ <- list(y = y, N = N, k = k_vec[h],
mu_0= mu_0,
alpha = alpha)
# Initial values
mu_inits<- c()
clust_inits <- kmeans(y, k_vec[h])$cluster
for (j in 1:k){
mu_inits[j]<-mean(y[clust_inits==j])
}
for (j in 1:k_vec[h]){
mu_inits[j]<-mean(y[clust_inits==j])
}
init1.univ <- dump.format(list(muOfClust=mu_inits,
tauOfClust= runif(k_vec[h], 0,10),
pClust=rep(1/k_vec[h],k_vec[h]),
clust=clust_inits))
moni.univ <- c("clust","muOfClust","tauOfClust","pClust", "dic")
mod   <- mod.mist.univ
dati  <- dati.univ
init1 <- init1.univ
moni  <- moni.univ
chains=3
nMC
burn
burn<-200
# Jags execution
ogg.jags <- run.jags(model=mod, data=dati, monitor=moni,
inits=init1, n.chains=chains,plots=FALSE, thin=1,
sample=nMC, burnin=burn)
# Jags execution
ogg.jags <- run.jags(model=mod, data=dati, monitor=moni,
inits=init1, n.chains=chains,plots=FALSE, thin=1,
sample=nMC, burnin=burn)
