ind.gi  <- rbind(ind.gi,c(j,sort(C[j,com.gi],
decreasing=TRUE)))
ind.gi1 <- rbind(ind.gi1,c(j,
# criteria involving maximization
#max(C[j,com.gi],na.rm=TRUE),          #dropped
sum(C[j,com.gi],na.rm=TRUE),           #maxsumint
# criteria involving minimization
#min(C[j,com.gi],na.rm=TRUE),          #dropped
#min(C[j,com.ngi]),                    #dropped
sum(C[j,com.ngi]),                     #maxsumnoint
# another criterion involving maximization
sum(C[j,com.gi],na.rm=TRUE)-sum(C[j,com.ngi])))
}                                            #maxsumdiff
# Methods: from 1 to 4
# if (!is.null(ind.gi))
#   Cg[g.i, 1] <- com.gi[which.max(ind.gi1[,2])]
if (!is.null(ind.gi))
Cg[g.i, 1] <- com.gi[which.max(ind.gi1[,2])]
if (!is.null(ind.gi))
Cg[g.i, 2] <- com.gi[which.min(ind.gi1[,3])]
if (!is.null(ind.gi))
Cg[g.i, 3] <- com.gi[which.min(ind.gi1[,4])]
# if (!is.null(ind.gi))
#   Cg[g.i, 5] <- com.gi[which.min(ind.gi1[,6])]
# if (!is.null(ind.gi))
#   Cg[g.i, 6] <- com.gi[which.max(ind.gi1[,7])]
# if (available_met==4){
# if (!is.null(ind.gi))
#   Cg[, 4]    <-  t(maxima)
# }
if (!is.null(ind.gi)){
Cg1[g.i] <- ind.gi[do.call(order,
as.data.frame(-ind.gi[,-1]))[1],1]
}
}
# For each method, we store the selected pivotal units
Cg <- Cg[,1:3]
# group1 contains the observation assigments to the groups obtained via pivots
group1 <- 0*ZM
# cycle on iterations
for (i in 1:ncol(ZM)){
# cycle on number of groups
for (j in 1:k){
if (!is.na(Cg[j])){
group1[ZM[,i] ==ZM[Cg[j],i],i] <- j
}
}
}
# definition of the probabilities to belong to the groups for each unit
pr <- matrix(NA,nrow=k,ncol=N)
for (kk in 1:k){
pr[kk,] <- apply(group1,1,FUN=function(x) sum(x==kk)/length(x))
}
# definition of the submatrix corresponding to the pivotal units
submatrix <- round(C[Cg,Cg],5)
T <- max(submatrix[upper.tri(submatrix)])
return(list(pr=pr, pivots=Cg, Submatrix=submatrix, Max=T))
}
clust  <-  piv_sel(C=C, k=k, clusters=as.vector(grr),ZM=zm)
N
N <- dim(C)[1]
N
Cg1 <- rep(NA, k)
Cg  <- matrix(NA, ncol=3, nrow=k)
clusters= as.vector(grr)
ZM=zm
dim(zm)
piv_sel<-function( C, k, clusters, ZM){
N <- dim(C)[1]
Cg1 <- rep(NA, k)
Cg  <- matrix(NA, ncol=3, nrow=k)
for (g.i in 1:k){
com.gi  <-  (1:N)[clusters==g.i]
com.ngi <-  (1:N)[clusters!=g.i]
ind.gi  <- c()
ind.gi1 <- c()
# choose the pivots within each group
for (j in com.gi){
ind.gi  <- rbind(ind.gi,c(j,sort(C[j,com.gi],
decreasing=TRUE)))
ind.gi1 <- rbind(ind.gi1,c(j,
# criteria involving maximization
#max(C[j,com.gi],na.rm=TRUE),          #dropped
sum(C[j,com.gi],na.rm=TRUE),           #maxsumint
# criteria involving minimization
#min(C[j,com.gi],na.rm=TRUE),          #dropped
#min(C[j,com.ngi]),                    #dropped
sum(C[j,com.ngi]),                     #maxsumnoint
# another criterion involving maximization
sum(C[j,com.gi],na.rm=TRUE)-sum(C[j,com.ngi])))
}                                            #maxsumdiff
# Methods: from 1 to 4
# if (!is.null(ind.gi))
#   Cg[g.i, 1] <- com.gi[which.max(ind.gi1[,2])]
if (!is.null(ind.gi))
Cg[g.i, 1] <- com.gi[which.max(ind.gi1[,2])]
if (!is.null(ind.gi))
Cg[g.i, 2] <- com.gi[which.min(ind.gi1[,3])]
if (!is.null(ind.gi))
Cg[g.i, 3] <- com.gi[which.min(ind.gi1[,4])]
# if (!is.null(ind.gi))
#   Cg[g.i, 5] <- com.gi[which.min(ind.gi1[,6])]
# if (!is.null(ind.gi))
#   Cg[g.i, 6] <- com.gi[which.max(ind.gi1[,7])]
# if (available_met==4){
# if (!is.null(ind.gi))
#   Cg[, 4]    <-  t(maxima)
# }
if (!is.null(ind.gi)){
Cg1[g.i] <- ind.gi[do.call(order,
as.data.frame(-ind.gi[,-1]))[1],1]
}
}
# For each method, we store the selected pivotal units
Cg <- Cg[,1:3]
# group1 contains the observation assigments to the groups obtained via pivots
group1 <- 0*ZM
# cycle on iterations
for (i in 1:ncol(ZM)){
# cycle on number of groups
for (j in 1:k){
if (!is.na(Cg[j])){
group1[ZM[,i] ==ZM[Cg[j],i],i] <- j
}
}
}
# definition of the probabilities to belong to the groups for each unit
pr <- matrix(NA,nrow=k,ncol=N)
for (kk in 1:k){
pr[kk,] <- apply(group1,1,FUN=function(x) sum(x==kk)/length(x))
}
# definition of the submatrix corresponding to the pivotal units
submatrix <- round(C[Cg,Cg],5)
T <- max(submatrix[upper.tri(submatrix)])
return(list(pr=pr, pivots=Cg, Submatrix=submatrix, Max=T))
}
clust  <-  piv_sel(C=C, k=k, clusters=as.vector(grr),ZM=zm)
clust$pivots
devtools::document()
library(pivmet)
N   <- 250
nMC <- 2500
k   <- 3
p   <- rep(1/k,k)
x   <- 3
stdev <- cbind(rep(1,k), rep(200,k))
Mu    <- seq(-trunc(k/2)*x,trunc(k/2)*x,length=k)
W     <- c(0.2,0.8)
sim   <- piv_sim(N,k,Mu,stdev,W=W)
res   <- piv_MCMC(sim$y, k, nMC)
rel   <- piv_rel(mcmc=res, nMC = nMC)
N <- 200
k <- 3
nMC <- 5000
M1  <- c(-.5,8)
M2  <- c(25.5,.1)
M3  <- c(49.5,8)
Mu  <- matrix(rbind(M1,M2,M3),c(k,2))
stdev <- cbind(rep(1,k), rep(200,k))
Sigma.p1 <- matrix(c(stdev[1,1],0,0,stdev[1,1]),
nrow=2, ncol=2)
Sigma.p2 <- matrix(c(stdev[1,2],0,0,stdev[1,2]),
nrow=2, ncol=2)
W <- c(0.2,0.8)
sim <- piv_sim(N,k,Mu,stdev,Sigma.p1,Sigma.p2,W)
res <- piv_MCMC(sim$y, k, nMC)
rel <- piv_rel(mcmc = res, nMC = nMC)
N  <- 620
k  <- 3
n1 <- 20
n2 <- 100
n3 <- 500
x  <- matrix(NA, N,2)
truegroup <- c( rep(1,n1), rep(2, n2), rep(3, n3))
for (i in 1:n1){
x[i,]=rmvnorm(1, c(1,5), sigma=diag(2))}
for (i in 1:n2){
x[n1+i,]=rmvnorm(1, c(4,0), sigma=diag(2))}
for (i in 1:n3){
x[n1+n2+i,]=rmvnorm(1, c(6,6), sigma=diag(2))}
# Apply piv_KMeans with MUS as pivotal criterion
res <- piv_KMeans(x, k)
devtools::document()
library(pivmet)
devtools::document()
library(pivmet)
devtools::document()
library(pivmet)
devtools::document()
library(pivmet)
data(iris)
help(iris)
dim(iris)
iris[1,]
x<- iris[,1:4]
data(iris)
x<- iris[,1:4]
N <- length(iris[,1])
H <- 1000
a <- matrix(NA, H, N)
for (h in 1:H){
a[h,] <- kmeans(x, centers = 3)$cluster
}
C <- matrix(1, N,N)
for (i in 1:(N-1)){
for (j in (i+1):N){
C[i,j] <- sum(a[,i]==a[,j])/H
C[j,i] <- C[i,j]
}}
C
ris <- piv_sel(C, clusters = a[1,])
piv_sel<-function(C, clusters){
N <- dim(C)[1]
k <- length(unique(clusters))
Cg1 <- rep(NA, k)
Cg  <- matrix(NA, ncol=3, nrow=k)
for (g.i in 1:k){
com.gi  <-  (1:N)[clusters==g.i]
com.ngi <-  (1:N)[clusters!=g.i]
ind.gi  <- c()
ind.gi1 <- c()
# choose the pivots within each group
for (j in com.gi){
ind.gi  <- rbind(ind.gi,c(j,sort(C[j,com.gi],
decreasing=TRUE)))
ind.gi1 <- rbind(ind.gi1,c(j,
# criteria involving maximization
#max(C[j,com.gi],na.rm=TRUE),          #dropped
sum(C[j,com.gi],na.rm=TRUE),           #maxsumint
# criteria involving minimization
#min(C[j,com.gi],na.rm=TRUE),          #dropped
#min(C[j,com.ngi]),                    #dropped
sum(C[j,com.ngi]),                     #maxsumnoint
# another criterion involving maximization
sum(C[j,com.gi],na.rm=TRUE)-sum(C[j,com.ngi])))
}                                            #maxsumdiff
# Methods: from 1 to 4
# if (!is.null(ind.gi))
#   Cg[g.i, 1] <- com.gi[which.max(ind.gi1[,2])]
if (!is.null(ind.gi))
Cg[g.i, 1] <- com.gi[which.max(ind.gi1[,2])]
if (!is.null(ind.gi))
Cg[g.i, 2] <- com.gi[which.min(ind.gi1[,3])]
if (!is.null(ind.gi))
Cg[g.i, 3] <- com.gi[which.min(ind.gi1[,4])]
# if (!is.null(ind.gi))
#   Cg[g.i, 5] <- com.gi[which.min(ind.gi1[,6])]
# if (!is.null(ind.gi))
#   Cg[g.i, 6] <- com.gi[which.max(ind.gi1[,7])]
# if (available_met==4){
# if (!is.null(ind.gi))
#   Cg[, 4]    <-  t(maxima)
# }
if (!is.null(ind.gi)){
Cg1[g.i] <- ind.gi[do.call(order,
as.data.frame(-ind.gi[,-1]))[1],1]
}
}
# For each method, we store the selected pivotal units
Cg <- Cg[,1:3]
# group1 contains the observation assigments to the groups obtained via pivots
# group1 <- 0*Z
# # cycle on iterations
#   for (i in 1:ncol(Z)){
# # cycle on number of groups
#     for (j in 1:k){
#       if (!is.na(Cg[j])){
#         group1[Z[,i] ==Z[Cg[j],i],i] <- j
#       }
#     }
#   }
#
# # definition of the probabilities to belong to the groups for each unit
# pr <- matrix(NA,nrow=k,ncol=N)
#  for (kk in 1:k){
#   pr[kk,] <- apply(group1,1,FUN=function(x) sum(x==kk)/length(x))
#  }
#
# # definition of the submatrix corresponding to the pivotal units
#
# submatrix <- round(C[Cg,Cg],5)
# T <- max(submatrix[upper.tri(submatrix)])
return(list(
#pr=pr,
pivots=Cg
#Submatrix=submatrix,
#Max=T
))
}
data(iris)
x<- iris[,1:4]
N <- length(iris[,1])
H <- 1000
a <- matrix(NA, H, N)
for (h in 1:H){
a[h,] <- kmeans(x, centers = 3)$cluster
}
C <- matrix(1, N,N)
for (i in 1:(N-1)){
for (j in (i+1):N){
C[i,j] <- sum(a[,i]==a[,j])/H
C[j,i] <- C[i,j]
}}
ris <- piv_sel(C, clusters = a[1,])
ris$pivots
source('~/GitHub/pivmet/R/pivotal.R')
source('~/GitHub/pivmet/R/pivotal.R')
source('~/GitHub/pivmet/R/pivotal.R')
source('~/GitHub/pivmet/R/pivotal.R')
piv_sel<-function(C, clusters){
N <- dim(C)[1]
k <- length(unique(clusters))
Cg1 <- rep(NA, k)
Cg  <- matrix(NA, ncol=3, nrow=k)
for (g.i in 1:k){
com.gi  <-  (1:N)[clusters==g.i]
com.ngi <-  (1:N)[clusters!=g.i]
ind.gi  <- c()
ind.gi1 <- c()
# choose the pivots within each group
for (j in com.gi){
ind.gi  <- rbind(ind.gi,c(j,sort(C[j,com.gi],
decreasing=TRUE)))
ind.gi1 <- rbind(ind.gi1,c(j,
# criteria involving maximization
#max(C[j,com.gi],na.rm=TRUE),          #dropped
sum(C[j,com.gi],na.rm=TRUE),           #maxsumint
# criteria involving minimization
#min(C[j,com.gi],na.rm=TRUE),          #dropped
#min(C[j,com.ngi]),                    #dropped
sum(C[j,com.ngi]),                     #maxsumnoint
# another criterion involving maximization
sum(C[j,com.gi],na.rm=TRUE)-sum(C[j,com.ngi])))
}                                            #maxsumdiff
# Methods: from 1 to 4
# if (!is.null(ind.gi))
#   Cg[g.i, 1] <- com.gi[which.max(ind.gi1[,2])]
if (!is.null(ind.gi))
Cg[g.i, 1] <- com.gi[which.max(ind.gi1[,2])]
if (!is.null(ind.gi))
Cg[g.i, 2] <- com.gi[which.min(ind.gi1[,3])]
if (!is.null(ind.gi))
Cg[g.i, 3] <- com.gi[which.min(ind.gi1[,4])]
# if (!is.null(ind.gi))
#   Cg[g.i, 5] <- com.gi[which.min(ind.gi1[,6])]
# if (!is.null(ind.gi))
#   Cg[g.i, 6] <- com.gi[which.max(ind.gi1[,7])]
# if (available_met==4){
# if (!is.null(ind.gi))
#   Cg[, 4]    <-  t(maxima)
# }
if (!is.null(ind.gi)){
Cg1[g.i] <- ind.gi[do.call(order,
as.data.frame(-ind.gi[,-1]))[1],1]
}
}
# For each method, we store the selected pivotal units
Cg <- Cg[,1:3]
colnames(Cg) <- c("maxsumint", "maxsumnoint", "maxsumdiff")
# group1 contains the observation assigments to the groups obtained via pivots
# group1 <- 0*Z
# # cycle on iterations
#   for (i in 1:ncol(Z)){
# # cycle on number of groups
#     for (j in 1:k){
#       if (!is.na(Cg[j])){
#         group1[Z[,i] ==Z[Cg[j],i],i] <- j
#       }
#     }
#   }
#
# # definition of the probabilities to belong to the groups for each unit
# pr <- matrix(NA,nrow=k,ncol=N)
#  for (kk in 1:k){
#   pr[kk,] <- apply(group1,1,FUN=function(x) sum(x==kk)/length(x))
#  }
#
# # definition of the submatrix corresponding to the pivotal units
#
# submatrix <- round(C[Cg,Cg],5)
# T <- max(submatrix[upper.tri(submatrix)])
return(list(
#pr=pr,
pivots=Cg
#Submatrix=submatrix,
#Max=T
))
}
data(iris)
x<- iris[,1:4]
N <- length(iris[,1])
H <- 1000
a <- matrix(NA, H, N)
for (h in 1:H){
a[h,] <- kmeans(x, centers = 3)$cluster
}
C <- matrix(1, N,N)
for (i in 1:(N-1)){
for (j in (i+1):N){
C[i,j] <- sum(a[,i]==a[,j])/H
C[j,i] <- C[i,j]
}}
ris <- piv_sel(C, clusters = a[1,])
ris$pivots
ris
plot(iris[,1], iris[,2])
head(iris)
plot(iris[,1], iris[,2], xlab ="Sepal.Length", ylab= "Sepal.Width",
col = a[1,]$cluster)
points( a[1,]$centers[, c("Sepal.Length","Sepal.Width" )], col = 1:3,
cex =2 )
plot(iris[,1], iris[,2], xlab ="Sepal.Length", ylab= "Sepal.Width",
col = a[1,]$cluster)
points( a[1,]$centers[, c("Sepal.Length","Sepal.Width" )], col = 1:3,
cex =2 )
devtools::document()
library(pivmet)
data(iris)
x<- iris[,1:4]
N <- length(iris[,1])
H <- 1000
a <- matrix(NA, H, N)
# Perform H k-means partitions
for (h in 1:H){
a[h,] <- kmeans(x, centers = 3)$cluster
}
# Build the co-association matrix
C <- matrix(1, N,N)
for (i in 1:(N-1)){
for (j in (i+1):N){
C[i,j] <- sum(a[,i]==a[,j])/H
C[j,i] <- C[i,j]
}}
km <- kmeans(x, centers =3)
# Find the pivots according to the three possible pivoyal criterion
ris <- piv_sel(C, clusters = km$cluster)
plot(iris[,1], iris[,2], xlab ="Sepal.Length", ylab= "Sepal.Width",
col = km$cluster)
points( km$centers[, c("Sepal.Length","Sepal.Width" )], col = 1:3,
cex =2 )
plot(iris[,1], iris[,2], xlab ="Sepal.Length", ylab= "Sepal.Width",
col = km$cluster)
# Add the pivots according to maxsumdiff criterion
points( x[ris$pivot[,3], c( "Sepal.Length","Sepal.Width" )], col = 1:3,
cex =2, pch = 8 )
dev.off()
plot(iris[,1], iris[,2], xlab ="Sepal.Length", ylab= "Sepal.Width",
col = km$cluster)
# Add the pivots according to maxsumdiff criterion
points( x[ris$pivot[,3], c( "Sepal.Length","Sepal.Width" )], col = 1:3,
cex =2, pch = 8 )
devtools::document()
library(pivmet)
devtools::document()
library(pivmet)
# Iris data
data(iris)
x<- iris[,1:4]
N <- length(iris[,1])
H <- 1000
a <- matrix(NA, H, N)
# Perform H k-means partitions
for (h in 1:H){
a[h,] <- kmeans(x, centers = 3)$cluster
}
# Build the co-association matrix
C <- matrix(1, N,N)
for (i in 1:(N-1)){
for (j in (i+1):N){
C[i,j] <- sum(a[,i]==a[,j])/H
C[j,i] <- C[i,j]
}}
km <- kmeans(x, centers =3)
# Find the pivots according to the three possible pivoyal criterion
ris <- piv_sel(C, clusters = km$cluster)
plot(iris[,1], iris[,2], xlab ="Sepal.Length", ylab= "Sepal.Width",
col = km$cluster)
# Add the pivots according to maxsumdiff criterion
points( x[ris$pivot[,3], c( "Sepal.Length","Sepal.Width" )], col = 1:3,
cex =2, pch = 8 )
N   <- 250
nMC <- 2500
k   <- 3
p   <- rep(1/k,k)
x   <- 3
stdev <- cbind(rep(1,k), rep(200,k))
Mu    <- seq(-trunc(k/2)*x,trunc(k/2)*x,length=k)
W     <- c(0.2,0.8)
sim   <- piv_sim(N,k,Mu,stdev,W=W)
res   <- piv_MCMC(sim$y, k, nMC)
rel   <- piv_rel(mcmc=res, nMC = nMC)
N <- 200
k <- 3
nMC <- 5000
M1  <- c(-.5,8)
M2  <- c(25.5,.1)
M3  <- c(49.5,8)
Mu  <- matrix(rbind(M1,M2,M3),c(k,2))
stdev <- cbind(rep(1,k), rep(200,k))
Sigma.p1 <- matrix(c(stdev[1,1],0,0,stdev[1,1]),
nrow=2, ncol=2)
Sigma.p2 <- matrix(c(stdev[1,2],0,0,stdev[1,2]),
nrow=2, ncol=2)
W <- c(0.2,0.8)
sim <- piv_sim(N,k,Mu,stdev,Sigma.p1,Sigma.p2,W)
res <- piv_MCMC(sim$y, k, nMC)
rel <- piv_rel(mcmc = res, nMC = nMC)
piv_plot(y=sim$y, mcmc=res, rel_est = rel, type="chains")
piv_plot(y=sim$y, mcmc=res, rel_est = rel,
type="estimates_hist")
setwd("C:/Users/leoeg/Dropbox/Loia")
sessionInfo()
