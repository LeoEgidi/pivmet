vector<lower=0>[D] L_tau;
}
transformed parameters{
vector[k] log_theta = log(theta);  // cache log calculation
vector[k] pz[N];
simplex[k] exp_pz[N];
matrix[D,D] L_Sigma=diag_pre_multiply(L_sigma, L_Omega);
matrix[D,D] L_Tau=diag_pre_multiply(L_tau, L_tau_Omega);
for (n in 1:N){
pz[n]=   multi_normal_cholesky_lpdf(y[n]|mu, L_Sigma)+
log_theta-
log_sum_exp(multi_normal_cholesky_lpdf(y[n]|
mu, L_Sigma)+
log_theta);
exp_pz[n] = exp(pz[n]);
}
}
model{
L_Omega ~ lkj_corr_cholesky(eta);
L_sigma ~ cauchy(0, sigma_d);
mu ~ multi_normal_cholesky(mu_0, L_Tau);
for (n in 1:N) {
vector[k] lps = log_theta;
for (j in 1:k){
lps[j] += multi_normal_cholesky_lpdf(y[n] |
mu[j], L_Sigma);
target+=pz[n,j];
}
target += log_sum_exp(lps);
}
}
generated quantities{
int<lower=1, upper=k> z[N];
for (n in 1:N){
z[n] = categorical_rng(exp_pz[n]);
}
}
"
fit_biv <-  stan(model_code = mix_biv,
data=data,
chains =chains,
iter =nMC)
sims_biv <- rstan::extract(fit_biv)
# Extraction
ris <- as.matrix(sims_biv)
# Post- process of the chains----------------------
group <- sims_biv$z
tau <- sims_biv$L_sigma
prob.st <- sims_biv$theta
M <- nrow(group)
mu_pre_switch_compl <- array(rep(0, M*2*k), dim=c(M,2,k))
for (i in 1:M)
mu_pre_switch_compl[i,,] <- t(sims_biv$mu[i,,])
# Discard iterations
numeffettivogruppi <- apply(group,1,FUN = function(x) length(unique(x)))
sm <- sims_biv$mu[numeffettivogruppi==k,,]
true.iter <- dim(sm)[1]
if (sum(numeffettivogruppi==k)==0){
return(print("HMC has not never been able to identify the required number of groups and the process has been interrupted"))
#return(1)
}else{
mu_pre_switch <- array(rep(0, true.iter*2*k), dim=c(true.iter,2,k))
for (i in 1:true.iter)
mu_pre_switch[i,,] <- t(sm[i,,])
}
mcmc_mean_raw = mu_pre_switch_compl
mcmc_weight_raw = prob.st
mcmc_sd_raw = tau
group <- sims_biv$z[numeffettivogruppi==k,]
mu <- mu_pre_switch
tau <- sims_biv$L_sigma[numeffettivogruppi==k, ]
prob.st <- sims_biv$theta[numeffettivogruppi==k,]
FreqGruppiJags <- table(group)
model_code <- mix_biv
}
group.orig <- group
verigruppi <- as.double(names(table(group)))
prob.st <- prob.st[,verigruppi]
mu <- mu[,,verigruppi]
#tau <- tau[,verigruppi]
# Switching Post
cont <- 0
for (l in verigruppi){
cont <- cont+1
group.orig[group==l] <- cont
}
k.orig <- k
if (cont > 1){
k <- cont
}
mu_switch  <- array(rep(0, true.iter*2*k), dim=c(true.iter,2,k))
prob.st_switch <-  array(0, dim=c(true.iter,k))
group <- group*0
z <- array(0,dim=c(N, k, true.iter))
for (i in 1:true.iter){
perm <- sample(1:k,k,replace=FALSE)
for (j in 1:k){
#post-processing
group[i,group.orig[i,]==j] <- perm[j]
}
mu_switch[i,,] <- mu[i,,perm]
prob.st_switch[i,] <- prob.st[i,perm]
}
for (i in 1:true.iter){
for (j in 1:N){
z[j,group[i,j],i] <- 1
}
}
mcmc_mean <- mu_switch
mcmc_sd <- tau
mcmc_weight <- prob.st_switch
}
FreqGruppiJagsPERM <- table(group)
Freq <- cbind(FreqGruppiJags,FreqGruppiJagsPERM)
colnames(Freq) <- c("JAGS raw groups", "JAGS post-processed groups")
# Similarity matrix based on MCMC sampling------------------------
nz <- dim(z)[1]
M <- dim(z)[3]
C <- matrix(1,nz,nz)
zm <- apply(z,c(1,3),FUN=function(x) sum(x*(1:length(x))))
for (i in 1:(nz-1)){
for (j in (i+1):nz){
C[i,j] <- sum(zm[i,]==zm[j,])/M
C[j,i] <- C[i,j]
}
}
matdissim <- 1-C
diag(matdissim) <- 0
# Clustering on dissimilarity matrix-------------
if (missing(clustering)){
#clustering <- "diana"
gr  <- diana(matdissim,diss=TRUE)
grr <- cutree(gr, k)
}else if(clustering =="diana"){
gr  <- diana(matdissim,diss=TRUE)
grr <- cutree(gr, k)
}else if(clustering == "hclust"){
gr  <- hclust(as.dist(matdissim))
grr <- cutree(gr, k)
}
available_met <- 3
piv.criterion.choices <- c("maxsumint", "minsumnoint",
"maxsumdiff")
if (missing(piv.criterion)){
piv.criterion <- "maxsumdiff"
}
if (piv.criterion=="maxsumint"||
piv.criterion=="minsumnoint"||
piv.criterion=="maxsumdiff" ){
piv.index <- (1:3)[piv.criterion.choices==piv.criterion]
piv.index.pivotal <- c(1,2,3)
available_met <- 3
x <- c(1:available_met)
clust  <-  piv_sel(C=C, clusters=as.vector(grr))
pivots <- clust$pivots[,piv.index.pivotal[piv.index]]
}else if(piv.criterion=="MUS"){
if (k <=4 & sum(C==0)!=0){
mus_res    <- MUS(C, grr)
clust  <-  mus_res$pivots
}else{
print("maxsumdiff criterion instead of MUS has been adopted due to
computational efficiency")
clust  <-  piv_sel(C=C,  clusters=as.vector(grr))
pivots <- clust$pivots[,3]
}
}
return(list( Freq=Freq,
true.iter = true.iter,
z=z,
Mu = mu_inits,
ris=ris,
groupPost=group,
mcmc_mean = mcmc_mean,
mcmc_sd = mcmc_sd,
mcmc_weight = mcmc_weight,
mcmc_mean_raw = mcmc_mean_raw,
mcmc_sd_raw = mcmc_sd_raw,
mcmc_weight_raw = mcmc_weight_raw,
C=C,
grr=grr,
pivots = pivots,
piv.criterion = piv.criterion,
nMC = nMC,
model = model_code))
}
y <- fish[,1]
k <- 5
nMC <- 5000
res <- piv_MCMC(y = y, k = k, nMC = nMC, priors=list(mu_0=0))
y <- fish[,1]
k <- 5
nMC <- 5000
res <- piv_MCMC(y = y, k = k, nMC = nMC, priors=list(g_0=20))
y <- fish[,1]
k <- 5
nMC <- 5000
res <- piv_MCMC(y = y, k = k, nMC = nMC, priors=list(mu_0=0, g_0=10^-16, G_0=10^-16, nu_0=20, S0=10^-16))
median(y)
y <- fish[,1]
k <- 5
nMC <- 5000
res <- piv_MCMC(y = y, k = k, nMC = nMC, priors=list(mu_0=5.6, g_0=10^-16, G_0=10^-16, nu_0=20, S0=10^-16))
y <- fish[,1]
k <- 5
nMC <- 5000
res <- piv_MCMC(y = y, k = k, nMC = nMC, priors=list(mu_0=5.6))
devtools::document()
setwd("~/GitHub/pivmet")
devtools::document()
devtools::document()
devtools::check()
help("pow")
help("power")
devtools::document()
devtools::check()
library(pivmet)
library(pivmet)
help(piv_rel)
help(piv_sim)
help(piv_MCMC)
devtools::document()
setwd("~/GitHub/pivmet")
library(pivmetabind)
library(pivmet)
help(piv_rel)
N <- 200
k <- 3
nMC <- 5000
M1  <- c(-.5,8)
M2  <- c(25.5,.1)
M3  <- c(49.5,8)
Mu  <- matrix(rbind(M1,M2,M3),c(k,2))
stdev <- cbind(rep(1,k), rep(200,k))
Sigma.p1 <- matrix(c(stdev[1,1]^2,0,0,stdev[1,1]^2),
nrow=2, ncol=2)
Sigma.p2 <- matrix(c(stdev[1,2]^2,0,0,stdev[1,2]^2),
nrow=2, ncol=2)
W <- c(0.2,0.8)
sim <- piv_sim(N,k,Mu,stdev,Sigma.p1,Sigma.p2,W)
res <- piv_MCMC(y = sim$y, k = k, nMC = nMC)
rel <- piv_rel(mcmc = res)
piv_plot(y=sim$y, mcmc=res, rel_est = rel, type="chains")
piv_plot(y=sim$y, mcmc=res, rel_est = rel, type="hist")
piv_plot <- function(y,
mcmc,
rel_est,
par = c("mean", "sd", "weight", "all"),
type = c("chains", "hist") ){
colori <- c("red", "green", "violet", "blue")
### checks
# par
list_par <- c("mean", "sd", "weight", "all")
if (sum(par!=list_par)==4){
stop(paste("object ", "'", par,"'", " not found.
Please select one among the following parameters:
mean, sd, weight, all", sep=""))
}
# type
list_type <- c("chains", "hist")
if (sum(type!=list_type)==2){
stop(paste("object ", "'", type,"'", " not found.
Please select one among the following types:
chains, hist", sep=""))
}
###
if (missing(par)){
par <- "all"
}
if (is.vector(y)){
est <- apply(rel_est$rel_mean,2,median)
}else{
est <- t(apply(rel_est$rel_mean, c(2,3), median))
}
if (par=="mean"){
rel <- rel_est$rel_mean
raw <- mcmc$mcmc_mean_raw
}else if(par=="sd"){
rel <- rel_est$rel_sd
raw <- mcmc$mcmc_sd_raw
}else if(par=="weight"){
rel <- rel_est$rel_weight
raw <- mcmc$mcmc_weight_raw
}else{
if (is.vector(y)){
rel <- array(0, dim =c(3, dim(rel_est$rel_mean)[1],
dim(rel_est$rel_mean)[2]))
raw <- array(0, dim =c(3, dim(mcmc$mcmc_mean_raw)[1],
dim(mcmc$mcmc_mean_raw)[2]))
rel[1,,] <-  rel_est$rel_mean
rel[2,,] <-  rel_est$rel_sd
rel[3,,] <-  rel_est$rel_weight
raw[1,,] <-  mcmc$mcmc_mean_raw
raw[2,,] <-  mcmc$mcmc_sd_raw
raw[3,,] <-  mcmc$mcmc_weight_raw
}else{
rel <- array(0, dim =c(3, dim(rel_est$rel_mean)[1],
dim(rel_est$rel_mean)[3]))
raw <- array(0, dim =c(3, dim(mcmc$mcmc_mean_raw)[1],
dim(mcmc$mcmc_mean_raw)[3]))
rel[1,,] <-  rel_est$rel_mean[,1,]
rel[2,,] <-  rel_est$rel_mean[,2,]
rel[3,,] <-  rel_est$rel_weight
raw[1,,] <-  mcmc$mcmc_mean_raw[,1,]
raw[2,,] <-  mcmc$mcmc_mean_raw[,2,]
raw[3,,] <-  mcmc$mcmc_weight_raw
}
}
n.iter <- rel_est$final_it
true.means <- mcmc$Mu
if (type=="chains" ){
mains <- c("mean", "sd", "weight")
ylabs <- c(expression(mu), expression(tau), expression(pi))
if (is.vector(y)){
if (par=="all"){
par(mfrow=c(2,3), oma=c(0,0,0,0), mar =c(5,3,2,1))
k <- dim(raw)[3]
for (j in 1:3){
#plot
matplot(raw[j,,], type="l", xlab="",
ylab=ylabs[j], main= paste("Raw ", mains[j],"s", sep=""), cex.lab =1.8,
cex.main=1.8)
}
for (j in 1:3){
#plot the relabeled
matplot(rel[j,,], type="l", xlab="Iterations",
ylab=ylabs[j], main= paste("Rel ", mains[j],"s", sep=""),
cex.main=1.8, cex.lab =1.8)
}
cat("Description: traceplots of the raw MCMC chains and the relabelled chains for all the model parameters: means, sds and weights. Each colored chain corresponds to one of the k distinct parameters of the mixture model. Overlapping chains may reveal that the MCMC sampler is not able to distinguish between the components.")
}else{
k <- dim(raw)[2]
par(mfrow=c(1,2), oma=c(0,0,0,0), mar =c(5,3,3,1))
#plot
matplot(raw, type="l", xlab="Iterations",
ylab="", main= paste("Raw ", par,"s", sep=""),
cex.main=1.8,cex.lab =1.8)
#plot the relabeled
matplot(rel, type="l",
xlab="Iterations",
ylab="",
main= paste("Rel ", par,"s", sep=""), cex.main=1.8,
cex.lab =1.8)
cat(paste("Description: traceplot of the raw MCMC chains and the relabelled chains for the "), par,"s parameters. Each colored chain corresponds to one of the k distinct parameters of the mixture model. Overlapping chains may reveal that the MCMC sample is not able to distinguish between the components.", sep="")
}
}else{
if (par=="all"){
par(mfrow=c(2,2), oma=c(0,0,0,0), mar =c(5,4.6,2,1))
k <- dim(raw)[3]
mains = c("mean 1st coord", "mean 2nd coord", "weight")
ylabs = c(expression(mu[,1]), expression(mu[,2]), expression(pi))
#
# for (j in 1:3){
#   #plot
#   matplot(raw[j,,], type="l", xlab="",
#           ylab=ylabs[j], main= paste("Raw ", mains[j], sep=""),
#           cex.main=1.8, cex.lab =1.8)
# }
# for (j in 1:3){
#   #plot the relabeled
#   matplot(rel[j,,], type="l", xlab="Iterations",
#           ylab=ylabs[j], main= paste("Rel ", mains[j], sep=""),
#           cex.lab =1.8, cex.main=1.8)
# }
h=1
plot(raw[1,,h], raw[2, ,h], col=h, pch =1, bg =h,
cex.main =1.8, main ="Raw means", cex.lab=1.8, xlab=
expression(mu[1]), ylab =expression(mu[2]),
xlim= c(min(raw[1,,]-10), max(raw[1,,])+10),
ylim= c(min(raw[2,,]-10), max(raw[2,,])+10))
for (h in 2:k){
points(raw[1,,h], raw[2, ,h], col=h, pch =1, bg=h)
}
matplot(raw[3,,], type="l",
ylab=ylabs[3], main= paste("Raw ", mains[3],"s", sep=""),
cex.main=1.8, cex.lab =1.8, xlab ="Iterations")
h=1
plot(rel[1,,h], rel[2, ,h], col=h, pch =1, bg =h,
cex.main =1.8, main ="Rel means", cex.lab=1.8, xlab=
expression(mu[1]), ylab =expression(mu[2]),
xlim= c(min(rel[1,,]-10), max(rel[1,,])+10),
ylim= c(min(rel[2,,]-10), max(rel[2,,])+10))
for (h in 2:k){
points(rel[1,,h], rel[2, ,h], col=h, pch =1, bg=h)
}
matplot(rel[3,,], type="l",
ylab=ylabs[3], main= paste("Rel ", mains[3],"s", sep=""),
cex.main=1.8, cex.lab =1.8, xlab ="Iterations")
cat("Description: traceplots of the raw MCMC chains and the relabelled chains for the model parameters means and weights. Each colored chain corresponds to one of the k distinct parameters of the mixture model. Overlapping chains may reveal that the MCMC sample is not able to distinguish between the components.")
}else{
if (par=="mean"){
k <- dim(raw)[3]
par(mfrow=c(1,2), oma=c(0,0,0,0), mar =c(5,4.6,2,1))
# matplot(raw[,1,], type="l", xlab="",
#         ylab=expression(mu[1]), main= paste("Raw ", par,"s", sep=""),
#         cex.lab =1.8, cex.main=1.8 )
# #plot the second component
# matplot(raw[,2,], type="l", xlab="",
#         ylab=expression(mu[2]), main= paste("Raw ", par,"s", sep=""),
#         cex.lab =1.8, cex.main=1.8)
#
# #plot the first relabelled component
# matplot(rel[,1,],type="l", xlab="Iterations",
#         ylab=expression(mu[1]),
#         main= paste("Rel ", par,"s", sep=""),cex.lab =1.8, cex.main=1.8)
#
# #plot the second relabelled component
# matplot(rel[,2,],type="l", xlab="Iterations",
#         ylab=expression(mu[2]),
#         main= paste("Rel ", par,"s", sep=""),cex.lab =1.8, cex.main=1.8)
h=1
plot(raw[,1,h], raw[, 2,h], col=h, pch =1, bg =h,
cex.main =1.8, main ="Raw means", cex.lab=1.8, xlab=
expression(mu[1]), ylab =expression(mu[2]),
xlim= c(min(raw[,1,]-10), max(raw[,1,])+10),
ylim= c(min(raw[,2,]-10), max(raw[,2,])+10))
for (h in 2:k){
points(raw[,1,h], raw[,2 ,h], col=h, pch =1, bg=h)
}
h=1
plot(rel[,1,h], rel[,2,h], col=h, pch =1, bg =h,
cex.main =1.8, main ="Rel means", cex.lab=1.8, xlab=
expression(mu[1]), ylab =expression(mu[2]),
xlim= c(min(rel[,1,]-10), max(rel[,1,])+10),
ylim= c(min(rel[,2,]-10), max(rel[,2,])+10))
for (h in 2:k){
points(rel[,1,h], rel[,2 ,h], col=h, pch =1, bg=h)
}
cat(paste("Description: traceplot of the raw MCMC chains and the relabelled chains for the "), par,"s parameters (coordinate 1 and 2). Each colored chain corresponds to one of the k distinct parameters of the mixture model. Overlapping chains may reveal that the MCMC sample is not able to distinguish between the components.", sep="")
}else if(par=="weight"){
par(mfrow=c(1,2), oma=c(0,0,0,0), mar =c(5,4.6,2,1))
matplot(raw, type="l", xlab="Iterations",
ylab=expression(pi), main= paste("Raw ", par,"s", sep=""),
cex.lab =1.8, cex.main=1.8)
matplot(rel,type="l", xlab="Iterations",
ylab=expression(pi),
main= paste("Rel ", par,"s", sep=""),
cex.lab =1.8, cex.main=1.8)
cat(paste("Description: traceplot of the raw MCMC chains and the relabelled chains for the "), par,"s parameters. Each colored chain corresponds to one of the k distinct parameters of the mixture model. Overlapping chains may reveal that the MCMC sample is not able to distinguish between the components.", sep="")
}else if (par=="sd"){
return(cat("No sds available in two dimensions: they are the same for each group"))
}
}
}
}else if(type=="hist"){
if (is.vector(y)){
par(mfrow=c(1,2), mar=c(5,5,4,1))
hist(y, breaks=40, prob = TRUE,
main = paste("Raw means"), cex.main =1.8,
col="navajowhite1", border="navajowhite1", cex.lab =1.8)
points(colMeans(mcmc$mcmc_mean_raw), rep(0, length(true.means)),
col="red", pch=21,  bg="red")
lines(density(y), lty=1, lwd=3, col="blue")
hist(y, breaks=40, prob = TRUE,
main= paste("Rel means"), cex.main=1.8,
col="navajowhite1", border="navajowhite1", cex.lab =1.8)
points(est, rep(0, length(true.means)),
col="red", pch=21,  bg="red")
lines(density(y), lty=1, lwd=3, col="blue")
cat("Description: histograms of the data along with the estimated posterior means (red points) from raw MCMC and relabelling algorithm. The blue line is the estimated density curve.")
}else{
par(mfrow=c(1,1), mar=c(3,3,2,1), oma =c(0,0,0,0))
xy <- y
nbins <- 20
x.bin <- seq(floor(min(xy[,1])),
ceiling(max(xy[,1])), length=nbins)
y.bin <- seq(floor(min(xy[,2])),
ceiling(max(xy[,2])), length=nbins)
freq <-  as.data.frame(table(findInterval(xy[,1],
x.bin),findInterval(xy[,2], y.bin)))
freq[,1] <- as.numeric(freq[,1])
freq[,2] <- as.numeric(freq[,2])
freq2D <- diag(nbins)*0
freq2D[cbind(freq[,1], freq[,2])] <- freq[,3]
#cols <- (freq2D[-1,-1] + freq2D[-1,-(nbins-1)] + freq2D[-(nbins-1),-(nbins-1)] + freq2D[-(nbins-1),-1])/4
res <- persp(x.bin, y.bin,
freq2D,   xlab="\n\n\nx",
ylab="\n\n\ny", zlab="\n\n\nf(x,y)",
theta=30, phi=30,
expand=0.5, ltheta=1,
lphi=1,
col = "white",
#"navajowhite1",
shade = 0.1, ticktype = "detailed",
main= paste("Rel means"), cex.main=1.8,
cex.lab =1.8)
points(trans3d(est[,1],
est[,2], -2,
pmat = res), col = "red", pch = 17,
cex=1.5)
# points(trans3d(est[,1],
#                est[,2], max(freq[,3])+1,
#                pmat = res), col = "red", pch = 16,
#        cex=1.5)
#lines(trans3d(est[,1], est[,2],
#             max(freq[,3])+1, pmat =res), col="red")
cat("Description: 3d histogram of the data along with the posterior estimates of the relabelled means (red points)")
}
}
# else if (type=="iter"){
#   par(mfrow=c(1,1))
#   barplot(n.iter, main="Proportion of valid iterations", ylim=c(0,1),
#           xlab="Pivotal criterion", ylab="Prop.", names.arg=c(1:7))
# }
}
piv_plot(y=sim$y, mcmc=res, rel_est = rel, type="hist")
devtools::document()
library(pivmet)
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
