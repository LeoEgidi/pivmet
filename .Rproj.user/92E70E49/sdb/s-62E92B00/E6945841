{
    "collab_server" : "",
    "contents" : "#' K-means Clustering Using MUS algorithm\n#'\n#' Perform k-means clustering on a data matrix using MUS algorithm for seeding initialization.\n#'\n#' @param x A numeric matrix of data, or an object that can be coerced to such a matrix (such as a numeric vector or a dataframe with all numeric columns).\n#' @param centers The number of clusters in the solution.\n#' @param piv.criterion The pivotal criterion used for detecting pivotal units. If \\code{centers <= 4}, default method is \\code{MUS}. If \\code{centers > 4}, the user may choose among the following: \\code{maxsumint, maxsumnoint, maxsumdiff}.\n#' @param iter.max The maximum number of iterations allowed.\n#' @param num.seeds\tThe number of different starting random seeds to use. Each random seed results in a different k-means solution.\n#' @param iter.mus The number of different ensembles for the MUS algorithm (if NULL, default is 1000)\n#' @param prec.par The precision parameter used in the MUS algorithm\n#' @param alg.type The type of clustering used for the initial seeding. Possible choices: \\code{kmeans}, \\code{KMeans}, \\code{hclust}.\n#'\n#'@return A list with components\n#'\n#'\\item{\\code{cluster}}{A vector of integers indicating the cluster to which each point is allocated.}\n#'\\item{\\code{centers}}{A matrix of cluster centres (centroids).}\n#'\\item{\\code{totss}}{The total sum of squares.}\n#'\\item{\\code{withinss}}{The within-cluster sum of squares for each cluster.}\n#'\\item{\\code{tot.withinss}}{The within-cluster sum of squares summed across clusters.}\n#'\\item{\\code{betwennss}}{The between-cluster sum of squared distances.}\n#'\\item{\\code{size}}{ The number of points in each cluster.}\n#'\\item{\\code{iter}}{The number of (outer) iterations.}\n#'\\item{\\code{ifault}}{integer: indicator of a possible algorithm problem â€“ for experts.}\n#'\\item{\\code{pivots}}{The pivotal units identified by the MUS algorithm}\n#'\n#'@author Leonardo Egidi \\url{legidi@units.it}\n#'@examples\n#'n  <- 620\n#'k  <- 3\n#'n1 <- 20\n#'n2 <- 100\n#'n3 <- 500\n#'x  <- matrix(NA, n,2)\n#'truegroup <- c( rep(1,n1), rep(2, n2), rep(3, n3))\n#'\n#'for (i in 1:n1){\n#'  x[i,]=rmvnorm(1, c(1,5), sigma=diag(2))}\n#'for (i in 1:n2){\n#'  x[n1+i,]=rmvnorm(1, c(4,0), sigma=diag(2))}\n#'for (i in 1:n3){\n#'  x[n1+n2+i,]=rmvnorm(1, c(6,6), sigma=diag(2))}\n#'\n#'res <- MUSKMeans(x, k)\n#'\n#'\n#'par(mfrow=c(1,2), pty=\"s\")\n#'colors_cluster <- c(\"grey\", \"darkolivegreen3\", \"coral\")\n#'colors_centers <- c(\"black\", \"darkgreen\", \"firebrick\")\n#'plot(x, col = colors_cluster[truegroup],\n#'    bg= colors_cluster[truegroup], pch=21, xlab=\"x[,1]\",\n#'    ylab=\"x[,2]\", cex.lab=1.5,\n#'    main=\"True data\", cex.main=1.5)\n#'\n#'plot(x, col = colors_cluster[res$cluster],\n#'    bg=colors_cluster[res$cluster], pch=21, xlab=\"x[,1]\",\n#'    ylab=\"x[,2]\", cex.lab=1.5,\n#'    main=\"MUSK-means\", cex.main=1.5)\n#'points(x[res$pivots[1],1], x[res$pivots[1],2],\n#'    pch=24, col=colors_centers[1],bg=colors_centers[1],\n#'    cex=1.5)\n#'points(x[res$pivots[2],1], x[res$pivots[2],2],\n#'    pch=24,  col=colors_centers[2], bg=colors_centers[2],\n#'    cex=1.5)\n#'points(x[res$pivots[3],1], x[res$pivots[3],2],\n#'    pch=24, col=colors_centers[3], bg=colors_centers[3],\n#'    cex=1.5)\n#'points(res$centers, col = colors_centers[1:k],\n#'    pch = 8, cex = 2)\n\n\n\nMUSKMeans <- function(x, centers, piv.criterion,\n  iter.mus, prec.par,\n  alg.type, iter.max, num.seeds){\n  #check on optional parameters\n  if (missing(piv.criterion)){\n    if (centers<=4 ){\n      piv.criterion <- \"MUS\"\n    }else{\n      piv.criterion <- \"maxsumdiff\"\n    }\n  }\n  if (missing(iter.mus)){\n    iter.mus <- 1000\n  }\n\n  if (missing(alg.type)){\n    alg.type <- \"KMeans\"\n  }\n\n  #type of clustering for initial clusters' assignment\n  if (alg.type==\"hclust\"){\n    cl <-cutree(hclust(dist(x), \"average\"),centers)\n  }else if (alg.type==\"KMeans\"){\n    cl <- KMeans(x,centers)$cluster\n  }else if(alg.type==\"kmeans\"){\n    cl <- kmeans(x,centers)$cluster\n  }\n\n  # tuning of precision MUS parameter\n  if (missing(prec.par)){\n    prec.par <- min( min(table(cl))-1, 5 )\n  }\n\n  #compute iter.mus different partitions\n  if (is.vector(x)){\n    n <- length(x)\n  }else{\n    n <- dim(x)[1]\n  }\n  H <- iter.mus\n  a <- matrix(NA, H, n)\n\n  for (h in 1:H){\n    a[h,] <- kmeans(x,centers)$cluster\n  }\n  sim_matr <- matrix(1, n,n)\n\n  for (i in 1:(n-1)){\n    for (j in (i+1):n){\n      sim_matr[i,j] <- sum(a[,i]==a[,j])/H\n      sim_matr[j,i] <- sim_matr[i,j]\n    }\n  }\n\n  if (centers <=4){\n    if (piv.criterion==\"MUS\"){\n\n      #MUS algorithm\n      prec.par <- prec.par\n      mus_res  <- MUS(sim_matr, cl, prec.par)\n      pivots   <- mus_res$maxima\n    }else if (piv.criterion!=\"MUS\"){\n\n      #Other pivotal criteria\n      z <- array(0,dim=c(n, centers, H))\n      for (i in 1:H){\n        for (j in 1:n){\n          z[j,a[i,j],i] <- 1\n        }\n      }\n      zm <- apply(z,c(1,3),FUN=function(x) sum(x*(1:length(x))))\n      piv_sel <- pivotal_selection(Obj=c(1:7),\n        k=centers, gIndex=cl,\n        C=sim_matr, n=n, ZM=zm, maxima=c(1:centers),\n        available_met = 7)\n      if (piv.criterion==\"maxsumint\"){\n        pivots <- piv_sel$Cg[,2]\n      }else if(piv.criterion==\"maxsumnoint\"){\n        pivots <- piv_sel$Cg[,5]\n      }else if(piv.criterion==\"maxsumdiff\"){\n        pivots <- piv_sel$Cg[,6]\n      }\n    }\n  }else{\n    z <- array(0,dim=c(n, centers, H))\n    for (i in 1:H){\n      for (j in 1:n){\n        z[j,a[i,j],i] <- 1\n      }\n    }\n    zm <- apply(z,c(1,3),FUN=function(x) sum(x*(1:length(x))))\n    piv_sel <- pivotal_selection(Obj=c(1:6),\n      k=centers, gIndex=cl,\n      C=sim_matr, n=n, ZM=zm, maxima=pivots,\n      available_met = 6)\n    if (piv.criterion==\"maxsumint\"){\n      pivots <- piv_sel$Cg[,2]\n    }else if(piv.criterion==\"maxsumnoint\"){\n      pivots <- piv_sel$Cg[,5]\n    }else if(piv.criterion==\"maxsumdiff\"){\n      pivots <- piv_sel$Cg[,6]\n    }\n  }\n\n  #Initial seeding\n  if(is.vector(x)){\n    dim_x <- 1\n    start <- c()\n    for (k in 1:centers){\n      start[k] <- as.double(x[pivots[k]])\n    }\n  }else if(is.matrix(x)){\n    dim_x <- dim(x)[2]\n    start <- matrix(NA, centers, dim_x )\n    for (k in 1:centers){\n      start[k,] <- as.double(x[pivots[k],])\n    }\n  }\n\n\n  #MUSKmeans\n  d_mus   <- KMeans(x, centers=start)\n\n  return(list(cluster=d_mus$cluster,\n    centers=d_mus$centers,\n    totss=d_mus$totss,\n    withinss=d_mus$withinss,\n    tot.withinss=d_mus$tot.withinss,\n    betweenss=d_mus$betweenss,\n    size=d_mus$size,\n    iter=d_mus$iter,\n    ifaults=d_mus$ifault,\n    pivots = pivots,\n    piv.criterion = piv.criterion))\n}\n",
    "created" : 1531738616719.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3889354470",
    "id" : "E6945841",
    "lastKnownWriteTime" : 1528463998,
    "last_content_update" : 1528463998,
    "path" : "~/GitHub/pivmet/R/musk.R",
    "project_path" : "R/musk.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}