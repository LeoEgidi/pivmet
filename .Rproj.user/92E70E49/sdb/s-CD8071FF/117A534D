{
    "collab_server" : "",
    "contents" : "#' Perfrom the pivotal relabelling step and compute the relabelled posterior estimates\n#'\n#' This function allows to perform the pivotal relabelling procedure described in Egidi et al. (2017) and to obtain the relabelled posterior estimates.\n#'\n#' @param mu_switch The post-processed MCMC chains for the mean parameters.\n#' @param group The units' group membership obtained after post-processing the chain.\n#' @param clustering The output from clustering (\\code{diana} or \\code{HClust}).\n#' @param Mu the true means (or an estimate for them).\n#' @param nMC the number of total MCMC iterations (given in input for the function \\code{BayesMCMC}).\n#'\n#'@details\n#'Prototypical models in which the label switching problem arises are mixture models, where for a sample \\eqn{\\vy=(y_1,\\ldots,y_n)} we assume\n#'  \\deqn{\n#' (Y_i|Z_i=j) \\sim f(y;\\mu_j,\\phi),\n#' }\n#' where the \\eqn{Z_i}, \\eqn{i=1,\\ldots,n}, are i.i.d.\\ random variables, \\eqn{g=j,\\dots,k},\n#' \\eqn{\\phi} is a parameter which is common to all components,  \\eqn{Z_i\\in\\{1,\\ldots,k\\}},\n#' and\n#'\\deqn{\n#' P(Z_i=k)=\\pi_k.\n#' }\n#' we assume that an MCMC sample is obtained from the posterior distribution for model above--for instance via \\code{bayesMCMC} function--with a prior distribution which is labelling invariant.\n#'We denote as \\eqn{\\{\\ca{\\theta}:h=1,\\ldots,H\\}} the sample for the parameter \\eqn{\\theta}\n#'=(\\vmu,\\vpi,\\phi)\\}, \\eqn{H} being the number of MCMC iterations.\n#'We assume that also a MCMC sample for the variable \\eqn{Z} is obtained and denote it by  \\eqn{\\{\\ca{Z}:h=1,\\ldots,H\\}}.\n#' Let, then, \\eqn{\\mathcal J_1,\\ldots,\\mathcal J_{k}} be a partition, obtained via \\code{diana} or \\code{hclust}.\n#' Furthermore, suppose that we can find \\eqn{k} units, \\eqn{i_1,\\ldots,i_{k}}, one\n#' for each group, which are (pairwise) separated with (posterior) probability one\n#' (that is, the posterior probability of any two of them being in the same group\n#' is zero). In terms of the matrix \\eqn{C} with elements \\eqn{c_{ip}=P(Z_i=Z_p|\\mathcal y\n#' )}, the \\eqn{k\\times k} submatrix with only the rows and columns correspondi\n#' ng to \\eqn{i_1,\\ldots,i_{k}}, will be the identity matrix.\n#' It is then straightforward to use the \\eqn{k} units, called pivots in what follows, to identify the groups and to relabel the chains: for each \\eqn{h=1,\\ldots, H} and \\eqn{j=1\n#', \\ldots,k}, set\n#' \\deqn{\n#' \\ca{\\mu_j}=\\ca{\\mu_{\\ca{Z_{i_j}}}};\n#' }\n#' \\deqn{\n#' \\ca{Z_i}=j \\mbox{ for } i:\\ca{Z_i}=\\ca{Z_{i_j}}.\n#' }\n#'First, although the model is based on a mixture of \\eqn{k} components, each iteration of the chain may imply a different number of non-empty groups (that is, it may be that \\eqn{[Z_i]_h\\neq k\\;\\; \\forall i} for some \\eqn{j,h}); let then \\eqn{\\ca{k}\\leq k} be the number of non-empty groups at iteration \\eqn{h},\n#'\\deqn{\n#'  \\ca{k} = \\#\\{j: \\ca{Z_i}=j\\mbox{ for some }i\\},\n#'  }\n#' where \\eqn{\\#A} is the cardinality of the set \\eqn{A}.\n#' If \\eqn{\\ca{k}<k} for some \\eqn{h}, there cannot be \\eqn{k} perfectly separated units, and so there cannot be \\eqn{k} pivots.\n#' Hence, the relabelling procedure outlined above can be used only for the subset of the chain for which \\eqn{\\ca{k}=k}; let it be \\eqn{\\hh_k=\\{h:\\ca{k}= k\\}}, the \\code{true.iter} argument.\n#' Even if \\eqn{k} non-empty groups are available, however, there may not be \\eqn{k} perfectly separated units. Let us define\n#' \\deqn{\n#'  \\hh^{*}_k=\\{ h\\in\\hh_k : \\exists r,s \\mbox{ s.t. } \\ca{Z_{i_r}}=\\ca{Z_{i_s}} \\}\n#'  }\n#' that is, the set of iterations where (at least) two pivots are in the same group.\n#'In order for the pivot method to be applicable, we need to exclude iterations #'\\eqn{\\hh^*_k}; that is, we can perform the pivot relabelling on \\eqn{\\hh_k-\\hh_k^*}.\n#' @return This function gives the relabelled posterior estimates--both mean and medians--obtained from the Markov chains of the MCMC sampling.\n#'\n#' \\item{\\code{mu_rel_mean}}{ Estimated posterior means}\n#' \\item{\\code{mu_rel_median}}{ Estimated posterior medians}\n#' \\item{\\code{mu_rel_complete}}{Complete relabelled chains}\n#'\n#' @author Leonardo Egidi \\url{legidi@units.it}\n#' @references Egidi, L., Pappada, R., Pauli, F. and Torelli, N. (2018). Relabelling in Bayesian Mixture\n#'Models by Pivotal Units. Statistics and Computing, 28(4), 957-969, DOI 10.1007/s11222-017-  9774-2.\n#' @examples\n#'\n#' #Univariate simulation\n#'\n#' N <- 200\n#' nMC <- 2000\n#' k <- 4\n#' p <- rep(1/k,k)\n#' x <- 3\n#' stdev <- cbind(rep(1,k), rep(200,k))\n#' Mu <- seq(-trunc(k/2)*x,trunc(k/2)*x,length=k)\n#' W <- c(0.2,0.8)\n#' sim <- sim_mixture(N,k,Mu,stdev,W=W)\n#' output_bayes <- bayesMCMC(sim$y, k, nMC)\n#' relab_est <-\n#' pivotal_relabelling(mu_switch = output_bayes$mu_switch,\n#'                     group = output_bayes$groupPost,\n#'                     clustering= output_bayes$clust_sel,\n#'                     Mu=output_bayes$Mu,\n#'                     nMC = nMC)\n#'\n#'\n#' plot_pivotal(y= sim$y,\n#'              est = relab_est$mu_rel_median,\n#'              chains=relab_est$mu_rel_complete,\n#'              type=\"chains\",\n#'              mu_switch=output_bayes$mu_switch,\n#'              n.iter=relab_est$Final_it,\n#'              true.means= output_bayes$Mu)\n#'\n#' plot_pivotal(y= sim$y,\n#'              est = relab_est$mu_rel_median,\n#'              chains=relab_est$mu_rel_complete,\n#'              type=\"estimates\",\n#'              mu_switch=output_bayes$mu_switch,\n#'              n.iter=relab_est$Final_it,\n#'              true.means= output_bayes$Mu)\n#'\n#' plot_pivotal(y= sim$y,\n#'              est = relab_est$mu_rel_median,\n#'              chains=relab_est$mu_rel_complete,\n#'              type=\"estimates_hist\",\n#'              mu_switch=output_bayes$mu_switch,\n#'              n.iter=relab_est$Final_it,\n#'              true.means= output_bayes$Mu)\n#'\n#'\n#' #Bivariate simulation\n#'\n#' N <- 200\n#' k <- 3\n#' nMC <- 5000\n#' M1  <- c(-.5,8)\n#' M2  <- c(25.5,.1)\n#' M3  <- c(49.5,8)\n#' Mu  <- matrix(rbind(M1,M2,M3),c(k,2))\n#' stdev <- cbind(rep(1,k), rep(200,k))\n#' Sigma.p1 <- matrix(c(stdev[1,1],0,0,stdev[1,1]),\n#'                    nrow=2, ncol=2)\n#' Sigma.p2 <- matrix(c(stdev[1,2],0,0,stdev[1,2]),\n#'                    nrow=2, ncol=2)\n#' W <- c(0.2,0.8)\n#' sim <- sim_mixture(N,k,Mu,stdev,Sigma.p1,Sigma.p2,W)\n#' output_bayes <- bayesMCMC(sim$y, k, nMC)\n#' relab_est <-\n#' pivotal_relabelling(mu_switch=output_bayes$mu_switch,\n#'                  group=output_bayes$groupPost,\n#'                  clustering=output_bayes$clust_sel,\n#'                  Mu=output_bayes$Mu,\n#'                  nMC = nMC)\n#'\n#' plot_pivotal(y= sim$y,\n#'              est = relab_est$mu_rel_median,\n#'              chains=relab_est$mu_rel_complete,\n#'              type=\"chains\",\n#'              mu_switch=output_bayes$mu_switch,\n#'              n.iter=relab_est$Final_it,\n#'              true.means= output_bayes$Mu)\n#'\n#' plot_pivotal(y= sim$y,\n#'              est = relab_est$mu_rel_median,\n#'              chains=relab_est$mu_rel_complete,\n#'              type=\"estimates_hist\",\n#'              mu_switch=output_bayes$mu_switch,\n#'              n.iter=relab_est$Final_it,\n#'              true.means= output_bayes$Mu)\n#'\n#'\n#'\n#' @export\n\npivotal_relabelling<-function(mu_switch, group, clustering,\n  Mu, nMC ){\n\n  true.iter <- dim(mu_switch)[1]\n  groupD <- array(NA, dim=c(true.iter, N))\n\n  # cycle on number of iterations\n  for (i in 1:true.iter){\n      # cycle on number of groups\n    for (j in 1:k){\n     groupD[i, group[i,]==group[i, clustering$Cg[j]]] <- j\n        #group[i, clustering[[u]]$Cg[j]]\n     }\n    }\n  # Finding final number of iterations : H_{G}-H^{*}_G, as explained     in the paper\n  contD <- c()\n  for (i in 1:true.iter){\n      contD[i] <- sum(is.na(groupD[i,])==TRUE)\n    }\n\n# Final_It contains the final valid number of iterations\n\n\n if (length(dim(mu_switch))==2){\n    k <- dim(mu_switch)[2]\n    mu_rel_median     <- c()  #vector of length k\n    mu_rel_mean       <- c()\n    mu_rel_median_tr  <- c()\n    mu_rel_mean_tr    <- c()\n    groupD2           <- groupD[contD==0,]\n    mu_switchD        <- mu_switch[contD==0,]\n    true.iterD2       <- sum(contD==0)\n    Final_It          <- true.iterD2/nMC\n    mu_rel_complete   <- matrix(NA,true.iterD2, k)\n\n\n    if (true.iterD2!=0){\n      for (m in 1:true.iterD2){\n        for ( j in 1:k){\n          vect_rel <- sort(mu_switchD[m,],\n            decreasing=FALSE, index.return=TRUE)$ix\n            mu_rel_complete[m,j] <-\n              mu_switchD[m,\n                vect_rel[groupD2[m, clustering$Cg[j]]] ]\n          }\n        }\n      }else{\n        mu_rel_median <- rep(NA,k)\n        mu_rel_mean   <- rep(NA,k)\n      }\n\n      mu_rel_median  <- apply(mu_rel_complete, 2, median)\n      mu_rel_mean    <- apply(mu_rel_complete, 2, mean)\n      mu_rel_median_tr  <- t(mu_rel_median)\n      mu_rel_mean_tr    <- t(mu_rel_mean)\n\n  }else{\n    k <- dim(mu_switch)[3]\n    mu_rel_median  <- array(NA,c(2,k))\n    mu_rel_mean    <- array(NA,c(2,k))\n    groupD2        <- groupD[contD==0,]\n    mu_switchD     <- mu_switch[contD==0,,]\n    true.iterD2    <- sum(contD==0)\n    Final_It       <- true.iterD2/nMC\n    mu_rel_complete  <- array(NA, dim=c(true.iterD2, 2,k))\n\n\n      if (true.iterD2!=0){\n        for (m in 1:true.iterD2){\n          for (j in 1:k){\n            mu_rel_complete[m,,j] <-\n              mu_switchD[m,,groupD2[m,clustering$Cg[j]]]\n          }\n        }\n      }else{\n        mu_rel_median <- matrix(NA,c(2,k))\n        mu_rel_mean   <- matrix(NA,c(2,k))\n\n      }\n\n    ind <- array(NA, c( nrow(mu_rel_complete) ,2, k))\n      for (g in 1:nrow(mu_rel_complete)){\n        prel1 <- c()\n        prel2 <- c()\n        for (h in 1:k){\n    prel1[h] <- which.min((mu_rel_complete[g,1,]-Mu[h,1])^2)\n    prel2[h] <- which.min((mu_rel_complete[g,2,]-Mu[h,2])^2)\n         }\n        ind[g,1,] <- prel1\n        ind[g,2,] <- prel2\n      }\n\n    mu_rel_median_tr  <- array(NA, c(k,2))\n    mu_rel_mean_tr    <- array(NA, c(k,2))\n\n for (h in 1:nrow(mu_rel_complete)){\n  mu_rel_complete[h,1,] <- mu_rel_complete[h,1, ind[h,1,]]\n  mu_rel_complete[h,2,] <- mu_rel_complete[h,2, ind[h,2,]]\n      }\n  mu_rel_median    <- apply(mu_rel_complete, c(2,3), median)\n  mu_rel_mean      <- apply(mu_rel_complete, c(2,3), mean)\n  mu_rel_median_tr <- t(mu_rel_median)\n  mu_rel_mean_tr   <- t(mu_rel_mean)\n    }\n\n return(list(mu_rel_median = mu_rel_median_tr,\n              mu_rel_mean = mu_rel_mean_tr,\n              mu_rel_complete = mu_rel_complete,\n              Final_It = Final_It))\n}\n\n",
    "created" : 1531739945328.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3301092752",
    "id" : "117A534D",
    "lastKnownWriteTime" : 1531748527,
    "last_content_update" : 1531748527884,
    "path" : "~/GitHub/pivmet/R/relab.R",
    "project_path" : "R/relab.R",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}